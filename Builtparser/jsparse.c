/*
*
* Copyright (c) Tanel Tammet 2004-2019
*
* Contact: tanel.tammet@gmail.com                 
*
* This file is part of GK
*
*/

 /** @file jsparse.c
 *  json input data parser 
 *
 */

/* ====== Includes =============== */



#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <stdarg.h>
#include <ctype.h>


#include "../Db/dbdata.h"
#include "../Db/dbmem.h"
#include "../Db/dballoc.h"
#include "../Db/dbdata.h"
#include "../Db/dbmpool.h"
#include "../Printer/dbotterprint.h"
#include "../Reasoner/clterm.h"
#include "../Reasoner/history.h"
//#include "../Reasoner/histctxt.h"
#include "dbparse.h"
#include "dbgenparse.h"
#include "dbotterparse.h"
#include "dbclausify.h"

#include "jsparse.h"
//#include "../json/yajl_all.h"
#include "../json/yajl_api.h"

#include "../Reasoner/printerrutils.h"  
#include "dbgenparse.h"


/* ====== Private headers and defs ======== */

//#define DEBUG
//#undef DEBUG
//#define IDEBUG

//#define DPRINTF(...) 

#define UNUSED(x) (void)(x);

//#define EXPAND_JSONLD_KEYS
#define EXPAND_JSONLD_TERMS
#define EXPAND_JSONLD_LISTKEYS

#define MARK_IMPORTED_NAMES
//#define IMPORTED_NAME_PREFIX "$imp_"

void json_err_printf2(char* s1, char* s2);
void json_err_printfn2(char* s1, int num, char* s2);
void json_err_printf3(char* s1, int num, char* s2);

static int wr_show_jsparse_error(glb* g, parse_parm* pp, char* format, ...);



/* code structure:


  wg_import_js_file takes filename, calls
    wr_import_js_file takes filename, initialises pp structure, calls
      wr_yajl_parse_file storing result in pp.result,
      wr_preprocess_json_clauselist takes pp.result (json parser result)
        loops over all formulas and calls
        wr_process_json_formula for each formula giving a tptp fof structure as result
        reverses the end result
      wr_js_parse_clauselist takes resultlist of tptp fof structures given by the preprocessor above
        loops over fof formulas and calls
        wr_flatten_logclause for each
        loops over the result of the previous wf_flatten_logclause result list of clauses and calls
          wr_js_parse_clause for each clause, taking clause, name, vardata etc
            and building a gk record of the clause 
          adds a record built by the prev wr_js_parse_clause
*/


/* ======== functions ========================= */


int wg_import_js_file(void *db, char* filename, int iskb, int* informat,
        int askpolarity, int* askinfo, int streaming) {  
  glb* g;
  int res;

#ifdef DEBUG
  printf("wg_import_js_file starts for file %s\n",filename); 
#endif
  g=wr_glb_new_simple(db); // no complex values given to glb elements 
  if (g==NULL) return 1;   
  (g->parser_print_level)=0;
  (g->print_initial_parser_result)=0;
  (g->print_generic_parser_result)=1;
  res=wr_import_js_file(g,filename,NULL,NULL,iskb,askpolarity,askinfo,streaming);
  if (g->parse_errmsg) {
    printf("%s\n",(g->parse_errmsg));
    sys_free(g->parse_errmsg);
    //res=1;
  } else if (dbmemsegh(db)->errflag) {
    wg_show_db_error(db);
    res=1;
  }
  /*
  if (res==1) {  
    if (0) { //} ((g->print_flag) &&  (g->print_level_flag)) {
      db_printf("No clauses generated by parser.\n");  
    }
  } else {
    //wg_mpool_print(db,pres2);
    if (0) { //((g->print_flag) && (g->print_generic_parser_result)>0) {    
      printf("\nGeneric parser result:\n");
      //wr_print_db_otter(g,(g->print_clause_detaillevel));
    }  
  } 
  */
  *informat=3;
  (g->print_json)=1; 
  (g->print_clauses_json)=1;
  sys_free(g); // no complex values given to glb elements

  //dprintf("wg_import_otterfile ends with res\n"); 
  return res;  
}

int wg_import_js_string(void *db, char* instr, int iskb, int* informat,
        int askpolarity, int* askinfo, int streaming) {  
  glb* g;
  int res;

#ifdef DEBUG
  printf("wg_import_js_file starts for file\n"); 
#endif
  g=wr_glb_new_simple(db); // no complex values given to glb elements 
  if (g==NULL) return 1;   
  (g->parser_print_level)=0;
  (g->print_initial_parser_result)=0;
  (g->print_generic_parser_result)=1;
  res=wr_import_js_file(g,"string",instr,NULL,iskb,askpolarity,askinfo,streaming);
  if (g->parse_errmsg) {
    printf("%s\n",(g->parse_errmsg));
    sys_free(g->parse_errmsg);
    //res=1;
  } else if (dbmemsegh(db)->errflag) {
    wg_show_db_error(db);
    res=1;
  }
  /*
  if (res==1) {  
    if (0) { //} ((g->print_flag) &&  (g->print_level_flag)) {
      db_printf("No clauses generated by parser.\n");  
    }
  } else {
    //wg_mpool_print(db,pres2);
    if (0) { //((g->print_flag) && (g->print_generic_parser_result)>0) {    
      printf("\nGeneric parser result:\n");
      //wr_print_db_otter(g,(g->print_clause_detaillevel));
    }  
  } 
  */
  *informat=3;
  (g->print_json)=1; 
  (g->print_clauses_json)=1;
  sys_free(g); // no complex values given to glb elements

  //dprintf("wg_import_otterfile ends with res\n"); 
  return res;  
}

int wr_import_js_file(glb* g, char* filename, char* strasfile, cvec clvec, int isincluded,
      int askpolarity, int* askinfo, int streaming) {
  void* db=g->db;
  parse_parm  pp;
  //char* fnamestr;  
  //FILE* fp;    
  //char* buf; 
  //int pres=1;
  void* preprocessed=NULL;
  void* pres2=NULL;
  void *mpool;
  int i,tmp_comp_funs;
  
#ifdef DEBUG
  //DPRINTF("wr_import_otter_file called\n");
  printf("\n filename %s \n",filename);
  printf("\n strasfile %s \n",strasfile);
  printf("\n isincluded %d \n",isincluded);
  (g->print_initial_parser_result)=1;
  (g->print_generic_parser_result)=1;
#endif        
  (g->print_initial_parser_result)=1;
  (g->print_generic_parser_result)=1;
  // set globals for parsing
  (g->filename)=filename;
  (g->parse_is_included_file)=isincluded;
  (g->parse_skolem_prefix)=wr_str_new(g,100);
  strncpy((g->parse_skolem_prefix),DEFAULT_SKOLEM_PREFIX,99);
  //(g->parse_skolem_nr)=0;
  (g->parse_newpred_prefix)=wr_str_new(g,100);
  strncpy((g->parse_newpred_prefix),DEFAULT_NEWPRED_PREFIX,99);
  //(g->parse_newpred_nr)=0;
  (g->parse_errmsg)=NULL;
  (g->parse_errflag)=0;

  tmp_comp_funs=(g->use_comp_funs);
  (g->use_comp_funs)=0;
  (g->in_has_fof)=0;

  //printf("\nwg_jsparse_data called\n");  
  mpool=wg_create_mpool(db,PARSER_MEMPOOL_SIZE);
  pp.askpolarity=askpolarity;
  pp.askinfo=0;
  pp.db=db;
  pp.filename=filename;
  pp.foo=NULL; // indicates file case in YY_INPUT in dbotter.l
  pp.result=NULL;
  pp.mpool=mpool;
  pp.depth=0;
  pp.formulanr=0;

  pp.jsonnull=wg_mkatom(db,mpool,WG_URITYPE,MPOOL_JSON_NULL,NULL);
  pp.jsonstruct=wg_mkatom(db,mpool,WG_URITYPE,MPOOL_STRUCT_PREFSTR,NULL);
  pp.jsontrue=wg_makelogtrue(db,mpool);
  pp.jsonfalse=wg_makelogfalse(db,mpool);
  pp.jsonempty=wg_mkatom(db,mpool,WG_URITYPE,MPOOL_JSON_EMPTY,NULL);

  pp.logfof=wg_mkatom(db,mpool,WG_URITYPE,MPOOL_JSON_FOF,NULL);
  pp.logtrue=pp.jsontrue; //wg_makelogtrue(db,mpool);
  pp.logfalse=pp.jsonfalse; //wg_makelogfalse(db,mpool);
  pp.logneg=wg_makelogneg(db,mpool);
  pp.logand=wg_mkatom(db,mpool,WG_ANONCONSTTYPE,"and",NULL); //wg_makelogand(db,mpool);  
  pp.logprefixand=wg_mkatom(db,mpool,WG_ANONCONSTTYPE,"and",NULL);
  pp.logor=wg_makelogor(db,mpool);
  pp.logprefixor=wg_mkatom(db,mpool,WG_ANONCONSTTYPE,"or",NULL);
  pp.logimp=wg_makelogimp(db,mpool);
  pp.logeqv=wg_makelogeqv(db,mpool);
  pp.logall=wg_mkatom(db,mpool,WG_ANONCONSTTYPE,"all",NULL); //wg_makelogall(db,mpool);
  pp.logexists=wg_mkatom(db,mpool,WG_ANONCONSTTYPE,"exists",NULL); //wg_makelogexists(db,mpool); 
  pp.logat=wg_makelogat(db,mpool); 
  pp.atomeq=wg_makeatomeq(db,mpool); 

  pp.logask=wg_mkatom(db,mpool,WG_URITYPE,MPOOL_JSON_ASK,NULL); 

  pp.freevars=NULL;
  pp.freevarsnr=0;
  pp.nullvars=NULL;
  pp.nullvarsnr=0;
  pp.boundvars=NULL;
  pp.json=(g->print_json);
  pp.jsonld_typekey=wg_mkatom(db,mpool,WG_URITYPE,"@type",NULL);
  pp.jsonld_typerepl=wg_mkatom(db,mpool,WG_URITYPE,
                    "http://www.w3.org/1999/02/22-rdf-syntax-ns#type",NULL);  
  pp.jsonld_vocabkey=wg_mkatom(db,mpool,WG_URITYPE,"@vocab",NULL);                                        
  pp.jsonld_basekey=wg_mkatom(db,mpool,WG_URITYPE,"@base",NULL);  
  /*
  if (!isincluded) {
    pp.jsonld_blankseed=1;
    pp.jsonld_blankcount=0;
  } 
  */ 
  pp.jsonld_blankprefatom=wg_mkatom(db,mpool,WG_URITYPE,"upref",NULL); 
  pp.jsonld_blanks=wg_mkpair(db,mpool,pp.jsonstruct,NULL);
  pp.jsonld_ctxt=NULL;
  pp.jsonld_graphid=NULL;

  for(i=0;i<PARSE_NESTING_DEPTH;i++) {
    pp.nests[i]=NULL;
  } 
  if (!pp.logtrue || !pp.logfalse || !pp.logneg || !pp.logand || !pp.logor
      || !pp.logimp || !pp.logeqv || !pp.logall || !pp.logexists || !pp.atomeq 
      || !pp.jsonld_blanks) {
    wr_show_jsparse_error(g,&pp,
      "cannot initialize pp ctxt in wr_process_tptp_import_clause\n");
    return 1;
  }
  if (strasfile==NULL) {  
    // input from file
    //fnamestr=filename;
    //if (fnamestr && fnamestr[0]=='#') fnamestr=fnamestr+1;
#ifdef DEBUG
    printf("\nreading from file %s\n",filename);
#endif          
    wr_yajl_parse_file(g,&pp,filename, 
      clvec, isincluded,
      askpolarity, askinfo, mpool, streaming);   
  } else {
    // input from string      
    pp.filename="string";
    //strasfile="[-568,[7.459,-9.3e10, null, a]]";
#ifdef DEBUG
    printf("\nreading from string %s\n",strasfile);
#endif    
    pp.length = strlen(strasfile);
    pp.pos = 0;
    wr_yajl_parse_string(g,&pp,strasfile);       
  }   
#ifdef DEBUG
  printf("\njson parser result:\n");    
  wg_mpool_print(db,pp.result);
  printf("\n");
#endif
  if (pp.result!=NULL) {
    preprocessed=wr_preprocess_json_clauselist(g,&pp,clvec,pp.result,isincluded,streaming);
    //preprocessed=wr_clausify_clauselist(g,mpool,clvec,pp.result);
    if (!(dbmemsegh(db)->convert)) {
      // not needed for conversion only
      pres2=wr_js_parse_clauselist(g,mpool,clvec,preprocessed);
    }  
  }
  *askinfo=pp.askinfo;
  wg_free_mpool(db,mpool);
  (g->use_comp_funs)=tmp_comp_funs; 
  //if (pres || pres2==NULL) return 1;
  if (pres2==NULL) return 1;
  else return 0;  
}

int wg_is_jsfile(void* db,char* filename) {
  char* suff;

  UNUSED(db);
  if (!filename) return 0;  
  suff=strrchr(filename,'.');
  if (suff==NULL) return 0;
  if (!strncmp(suff,".js",strlen(".js"))) return 1;
  return 0;
}

int wg_is_js_streaming_file(void* db,char* filename) {
  char* suff;

  UNUSED(db);
  if (!filename) return 0;  
  suff=strrchr(filename,'.');
  if (suff==NULL) return 0;
  if (!strncmp(suff,".jss",strlen(".jss"))) return 1;
  return 0;
}



// =============== parsing json ==========



/* memory debugging routines */
typedef struct
{
    unsigned int numFrees;
    unsigned int numMallocs;   
    parse_parm* pp;
} yajlTestMemoryContext;

/* cast void * into context */

#define TEST_CTX(vptr) ((yajlTestMemoryContext *) (vptr))

/*
static void yajlTestFree(void * ctx, void * ptr)
{
    assert(ptr != NULL);
    TEST_CTX(ctx)->numFrees++;
    free(ptr);
}

static void * yajlTestMalloc(void * ctx, size_t sz)
{
    assert(sz != 0);
    TEST_CTX(ctx)->numMallocs++;
    return malloc(sz);
}

static void * yajlTestRealloc(void * ctx, void * ptr, size_t sz)
{
    if (ptr == NULL) {
        assert(sz != 0);
        TEST_CTX(ctx)->numMallocs++;
    } else if (sz == 0) {
        TEST_CTX(ctx)->numFrees++;
    }

    return realloc(ptr, sz);
}
*/

//#define BUF_SIZE 2048

static int parse_yajl_null(void *ctx) {
  //int stringLen;
  //char* stringVal;
  parse_parm *pp = (parse_parm *) ctx;

  //printf("\nnull\n");   
  //stringVal=MPOOL_JSON_NULL;
  //stringLen=strlen(stringVal);
  if (!(pp->depth)) {
    //(pp->result)=MKWGURILEN(pp, (char*)stringVal, (int)stringLen);      
    (pp->result)=pp->jsonnull;
  } else {
    //(pp->nests)[(pp->depth)]=
    //  MKWGPAIR(pp,MKWGURILEN(pp, (char*)stringVal, (int)stringLen),(pp->nests)[(pp->depth)]);
    (pp->nests)[(pp->depth)]=
      MKWGPAIR(pp,pp->jsonnull,(pp->nests)[(pp->depth)]);
  }  
  return 1;
}

static int parse_yajl_boolean(void * ctx, int boolVal) {
  //int stringLen;
  //char* stringVal;
  parse_parm *pp = (parse_parm *) ctx;
  void* val;

  //printf("\nbool %d\n",boolVal); 
  /*
  if (boolVal) {
    stringVal=MPOOL_JSON_TRUE;
  } else {
    stringVal=MPOOL_JSON_FALSE;
  }
  stringLen=strlen(stringVal);
  */
  if (boolVal) {
    val=pp->jsontrue;
  } else {
     val=pp->jsonfalse;
  } 
  if (!(pp->depth)) {
    //(pp->result)=MKWGURILEN(pp, (char*)stringVal, (int)stringLen);      
    (pp->result)=val;
  } else {
    //(pp->nests)[(pp->depth)]=
    //  MKWGPAIR(pp,MKWGURILEN(pp, (char*)stringVal, (int)stringLen),(pp->nests)[(pp->depth)]);
    (pp->nests)[(pp->depth)]=
      MKWGPAIR(pp,val,(pp->nests)[(pp->depth)]);
  }  
  return 1;
}

static int parse_yajl_integer(void *ctx, long long integerVal) {
  parse_parm *pp = (parse_parm *) ctx; 

  //printf("integer: %lld\n", integerVal);
  if (!(pp->depth)) {
    (pp->result)=MKWGINTDIRECT(pp, (gint)integerVal);       
  } else {
    (pp->nests)[(pp->depth)]=
      MKWGPAIR(pp,MKWGINTDIRECT(pp, (gint)integerVal),(pp->nests)[(pp->depth)]);
  } 
  return 1;
}

static int parse_yajl_double(void *ctx, double doubleVal) {
  parse_parm *pp = (parse_parm *) ctx; 
   
  //printf("double1: %f\n", doubleVal);
  if (!(pp->depth)) {
    (pp->result)=MKWGDOUBLEDIRECT(pp, ((double)doubleVal)); 
    //(pp->result)=MKWGINTDIRECT(pp, (gint)doubleVal);      
  } else {
    (pp->nests)[(pp->depth)]=
      MKWGPAIR(pp,MKWGDOUBLEDIRECT(pp, ((double)doubleVal)),(pp->nests)[(pp->depth)]);      
  } 
  return 1;
}

static int parse_yajl_string(void *ctx, const unsigned char * stringVal,
                            size_t stringLen) {      
  parse_parm *pp = (parse_parm *) ctx;

  //printf("\nstringLen %ld stringVal |%s|\n",(gint)stringLen,stringVal); 
  //(pp->result)=MKWGSTRINGLEN(pp, stringVal, stringLen); 
  if (!(pp->depth)) {
    (pp->result)=MKWGURILEN(pp, (char*)stringVal, (int)stringLen);      
  } else {
    (pp->nests)[(pp->depth)]=
      MKWGPAIR(pp,MKWGURILEN(pp, (char*)stringVal, (int)stringLen),(pp->nests)[(pp->depth)]);
  }  
  return 1;
}

static int parse_yajl_start_array(void *ctx) {  
  parse_parm *pp = (parse_parm *) ctx;   

  //printf("array open '['\n");
  (pp->depth)++; 
  (pp->nests)[(pp->depth)]=MKWGNIL;     
  //printf("\ndepth %d\n",(pp->depth));
  return 1;
}

static int parse_yajl_end_array(void *ctx) {  
  parse_parm *pp = (parse_parm *) ctx;

  //printf("array close ']'\n");  
  if (!((pp->depth)-1)) {
    if ((pp->nests)[(pp->depth)]==NULL) {
      ((pp->nests)[(pp->depth)])=pp->jsonempty;
    } else {
      (pp->nests)[(pp->depth)]=wg_inplace_reverselist(pp->db,pp->mpool,(pp->nests)[(pp->depth)]);
      (pp->result)=(pp->nests)[(pp->depth)];            
    }  
  } else {  
    if ((pp->nests)[(pp->depth)]==NULL) {
      ((pp->nests)[(pp->depth)-1])=//pp->jsonempty;
        MKWGPAIR(pp,pp->jsonempty,(pp->nests)[(pp->depth)-1]);  
    } else {
      (pp->nests)[(pp->depth)]=wg_inplace_reverselist(pp->db,pp->mpool,(pp->nests)[(pp->depth)]);
      (pp->nests)[(pp->depth)-1]=
        MKWGPAIR(pp,(pp->nests)[(pp->depth)],(pp->nests)[(pp->depth)-1]);      
    }    
  }
  (pp->depth)--; 
  //printf("\ndepth %d\n",(pp->depth));
  return 1;
}

static int parse_yajl_map_key(void *ctx, const unsigned char * stringVal,
                             size_t stringLen) {
  return parse_yajl_string(ctx,stringVal,stringLen);
}

static int parse_yajl_start_map(void *ctx) {
  //int stringLen;
  //char* stringVal;
  parse_parm *pp = (parse_parm *) ctx;     

  //printf("map open '{'\n");
  (pp->depth)++;
  (pp->nests)[(pp->depth)]=MKWGNIL;
  //stringVal=MPOOL_STRUCT_PREFSTR;
  //stringLen=strlen(stringVal);
  //(pp->nests)[(pp->depth)]=
  //  MKWGPAIR(pp,MKWGURILEN(pp, (char*)stringVal, (int)stringLen),(pp->nests)[(pp->depth)]);
  (pp->nests)[(pp->depth)]=
    MKWGPAIR(pp,pp->jsonstruct,(pp->nests)[(pp->depth)]);  
  //printf("\ndepth %d\n",(pp->depth));
  return 1;
}

static int parse_yajl_end_map(void *ctx) {  
  parse_parm *pp = (parse_parm *) ctx;

  //printf("\nmap close '}'\n");
  if (!((pp->depth)-1)) {
    (pp->nests)[(pp->depth)]=wg_inplace_reverselist(pp->db,pp->mpool,(pp->nests)[(pp->depth)]);
    (pp->result)=(pp->nests)[(pp->depth)];  
    //(pp->result)=wg_reverselist(pp->db,pp->mpool,(pp->result));          
  } else {  
    (pp->nests)[(pp->depth)]=wg_inplace_reverselist(pp->db,pp->mpool,(pp->nests)[(pp->depth)]);
    (pp->nests)[(pp->depth)-1]=
      MKWGPAIR(pp,(pp->nests)[(pp->depth)],(pp->nests)[(pp->depth)-1]); 
    //(pp->nests)[(pp->depth)-1]=wg_reverselist(pp->db,pp->mpool,(pp->nests)[(pp->depth)-1]);
  }
  (pp->depth)--; 
  //printf("\ndepth %d\n",(pp->depth));  
  return 1;
}

static yajl_callbacks callbacks = {
  parse_yajl_null,
  parse_yajl_boolean,
  parse_yajl_integer,
  parse_yajl_double,
  NULL,
  parse_yajl_string,
  parse_yajl_start_map,
  parse_yajl_map_key,
  //parse_yajl_string,
  parse_yajl_end_map,
  parse_yajl_start_array,
  parse_yajl_end_array
};



int wr_yajl_parse_file(glb* g, parse_parm* pp, char* filename,
      cvec clvec, int isincluded,
      int askpolarity, int* askinfo, void* mpool, int streaming) {
  void *db=g->db; 
  yajl_handle hand;
  FILE *file;
  yajl_status stat;
  size_t rd;
  unsigned char *line, *str;  
  size_t len;        
  int bytes;
  int lines, i, endfound=0;
  void *streamlist=NULL;   
  yajlTestMemoryContext memCtx;  
  char errbuf[110];   

  UNUSED(g);
  // memory allocation debugging: allocate a structure which collects
  // statistics    
  memCtx.numFrees=0;
  memCtx.numMallocs=0;
  memCtx.pp=pp;
  // allocate the parser 
  //hand = yajl_alloc(&callbacks, &allocFuncs, NULL);
  hand = yajl_alloc(&callbacks, NULL, (void*)pp);
  // configure parser
  yajl_config(hand, yajl_allow_comments, 1);
  yajl_config(hand, yajl_allow_multiple_values, 1); 
  // open file
  //fileData = (unsigned char *) malloc(bufSize);  
  if (filename) { 
    file = fopen(filename, "r");
    if (!file) {
      json_err_printf2("could not open",filename);      
      //printf("\ncould not open %s\n",filename);
      return -1;
    }
  } else {    
    json_err_printf2("no filename given",filename);
    //printf("\nno filename givenn");
    return -1;
  }
  //printf("\nstart to read\n");
  line=NULL;
  len=0;      
  lines=1;
  for (;;lines++) {     
    bytes = wg_getline(&line, &len, file);    
    //printf("\nline %d read %d bytes\n",lines,bytes);
    //printf("\n|%s|\n",line);
    rd=(size_t)bytes;
    if (bytes<=0) {
      //printf("\nline %d bytes %d feof(file) %d\n",lines,bytes,feof(file));
      if (!feof(file)) {
        json_err_printf2("error reading from",filename);
        //printf("\nerror reading from %s\n", filename);
      } else {
        //endfound=1;
      }     
      break;
    } else {            
      // read file data, now pass to parser
      if (streaming) {        
        (pp->result)=NULL; // clear result
      }  
      stat = yajl_parse(hand, line, rd);
      if (streaming && (pp->result!=NULL)) {       
        streamlist=wg_mkpair(db,mpool,(pp->result),streamlist);         
      }          
      if (stat != yajl_status_ok) break;
    }
  }     
  if (streaming) (pp->result)=wg_inplace_reverselist(db,mpool,streamlist);  
  stat = yajl_complete_parse(hand);
  if ((stat != yajl_status_ok) && !endfound) {
    str =  yajl_get_error(hand, 0, line, rd);
    //fflush(stdout);
    //json_err_printf2("could not open file",fnamestr);
    if (str && strlen((char*)str)<100) {
      // remove trailing newline
      strcpy(errbuf,(char*)str);
      for(i=0; errbuf[i] && i<100;i++) {
        if (errbuf[i]=='\n') { errbuf[i]=(char)0; break; }        
      }
      json_err_printfn2("json syntax error at line ", lines,errbuf);         
    } else { 
      json_err_printfn2("json syntax error at line ", lines, (char *) str);            
    }  
    yajl_free_error(hand, (unsigned char *)str);
    return -1;
  }
  yajl_free(hand);
  if (line!=NULL) wr_free(g,line);
  if (filename) {
    fclose(file);
  }
  // finally, print out some memory statistics
  if (memCtx.numMallocs - memCtx.numFrees) {
    printf("memory leaks:\t%u\n", memCtx.numMallocs - memCtx.numFrees);
  }  
  return 0;
}



int wr_yajl_parse_string(glb* g, parse_parm* pp, char* strasfile) {
  yajl_handle hand;
  yajl_status stat;
  size_t rd;
  unsigned char *line;
  yajlTestMemoryContext memCtx;

  UNUSED(g);
  // memory allocation debugging: allocate a structure which collects
  // statistics 
  memCtx.numFrees=0;
  memCtx.numMallocs=0;
  memCtx.pp=pp;
 
  // allocate the parser 
  //hand = yajl_alloc(&callbacks, &allocFuncs, NULL);
  hand = yajl_alloc(&callbacks, NULL, (void*)pp);
  // configure parser
  yajl_config(hand, yajl_allow_comments, 1);
  yajl_config(hand, yajl_allow_multiple_values, 1); 
  //printf("\nstart to parse str\n");
  line=(unsigned char *) strasfile;
  rd=strlen(strasfile);
  stat = yajl_parse(hand, line, rd); 
  stat = yajl_complete_parse(hand);
  if (stat != yajl_status_ok) {
    unsigned char * str = yajl_get_error(hand, 0, line, rd);
    //fflush(stdout);
    json_err_printf2("json syntax error:",(char *) str);
    yajl_free_error(hand, str);
    return -1;
  }
  yajl_free(hand);
  // finally, print out some memory statistics
  if (memCtx.numMallocs - memCtx.numFrees) {
    //printf("memory leaks:\t%u\n", memCtx.numMallocs - memCtx.numFrees);
  }  
  return 0;
}

/*

getline replacement 

*/

int wg_getline(unsigned char **line, size_t *len, FILE *fp) {
  char chunk[128];

  // Check if either line, len or fp are NULL pointers
  if(line == NULL || len == NULL || fp == NULL) {        
    return -1;
  }        
  // Allocate a block of memory for *line if it is NULL or smaller than the chunk array
  if(*line == NULL || *len < sizeof(chunk)) {
    *len = sizeof(chunk);
    if((*line = malloc(*len)) == NULL) {     
      return -1;
    }
  }
  (*line)[0] = '\0';
  while(fgets(chunk, sizeof(chunk), fp) != NULL) {
    // Resize the line buffer if necessary
    size_t len_used = strlen((char*)(*line));
    size_t chunk_used = strlen(chunk);

    if(*len - len_used < chunk_used) {
      // Check for overflow
      if(*len > SIZE_MAX / 2) {
        return -1;
      } else {
        *len *= 2;
      }      
      if((*line = realloc(*line, *len)) == NULL) {
        return -1;
      }
    }
    // Copy the chunk to the end of the line buffer
    memcpy(*line + len_used, chunk, chunk_used);
    len_used += chunk_used;
    (*line)[len_used] = '\0';

    // Check if *line contains '\n', if yes, return the *line length
    if((*line)[len_used - 1] == '\n') {
      return len_used;
    } else {
      return len_used;
    }
  }
  return -1;
}

/* ----------- preprocess json clauselist ----------- */



void* wr_preprocess_json_clauselist
        (glb* g,parse_parm* pp,cvec clvec,void* clauselist, int isincluded, 
        int streaming) {
  void* mpool=pp->mpool;          
  void* db=g->db;
  void* lpart;
  void *cl; //, *clname, *clrole;
  void* resultclause=NULL;
  void* resultlist=NULL; 
  int clnr=0;
  //char namebuf[1000];
  //char rolebuf[100];  
#ifdef DEBUG  
  printf("wr_preprocess_json_clauselist starting with clauselist\n");  
  wg_mpool_print(db,clauselist);
  printf("\n");
#endif       

  // setup temporary buffer for conversion printing: this is updated as needed
  //printf("\n(dbmemsegh(db)->convert) %ld (dbmemsegh(db)->tptp) %d\n",
  //(dbmemsegh(db)->convert),(dbmemsegh(db)->tptp));
  if (dbmemsegh(db)->convert) {
    if (!(g->tmp_printbuf)) {
      (g->tmp_printbuf)=malloc(1000); // this is dynamically increased later
    }  
  }  
  if (!clauselist) {
    wr_show_jsparse_error(g,pp,"no data given");
    return NULL;
  }
  // detect if a keyvalue object
  // if yes, wrap into list
  if (wg_ispair(db,clauselist) && wg_first(db,clauselist)==(pp->jsonstruct)) {   
    clauselist=wg_mkpair(db,mpool,clauselist,NULL);
  }

  // loop over clauses


  for(lpart=clauselist,clnr=0;wg_ispair(db,lpart);lpart=wg_rest(db,lpart),clnr++) {
    if (g->parse_errflag) break;
    cl=wg_first(db,lpart);
#ifdef DEBUG    
    printf("\nclause nr %d:",clnr);    
    wg_mpool_print(db,cl); 
    printf("\n");   
#endif         
    /*
    if (!clnr && wg_isatom(db,cl) && wg_atomtype(db,cl)==WG_URITYPE &&
          !strcmp("formulas",wg_atomstr1(db,cl)) ) {
      clnr--;      
      continue;
    }
    */
    pp->formulanr=clnr+1;
    pp->parse_top_level=1;
    if (wg_isatom(db,cl) && wg_atomtype(db,cl)!=WG_URITYPE) {
      if (cl==(pp->logtrue)) continue;
      if (cl!=(pp->logfalse)) {
        wr_show_jsparse_error(g,pp,"not a proper formula at top level");
        break;
      } else {
        // make a falsehood        
      }
    }   
    if (wr_is_json_import_clause(db,pp,cl)) {
      // tptp import clause 
      if ((dbmemsegh(db)->convert) && (dbmemsegh(db)->tptp)) {
        // do not import when converting
        printf("\ninclude('%s').\n",wg_atomstr1(db,wg_nth(db,cl,2)));        
      } else {
        wr_process_json_import_clause(g,mpool,cl,clvec);
      }  
      resultclause=NULL;
    } else {      
      resultclause=wr_process_json_formula(g,pp,cl,isincluded);      
    } 
#ifdef DEBUG
    printf("\nin wr_preprocess_json_clauselist resultclause:\n");
    wg_mpool_print(db,resultclause); 
    printf("\n\n"); 
#endif
    if (resultclause!=NULL) {
      resultlist=wg_mkpair(db,mpool,resultclause,resultlist);  
    }  
  } // end clause list loop 
  //free(vardata); // if taken from mpool, not freed

  if (g->parse_errflag) {
    //printf("\n%s\n",g->parse_errmsg);
    return NULL;
  }

#ifdef DEBUG
  printf("\nin wr_preprocess_json_clauselist resultlist:\n");
  wg_mpool_print(db,resultlist); 
  printf("\n\n");  
#endif
   
  resultlist=wg_inplace_reverselist(db,mpool,resultlist);
  return resultlist;
}  

// like: {"@include": "Axioms/SWC001-0.ax"}

int wr_is_json_import_clause(void* db, parse_parm* pp, void* cl) {
  void* fun;

  if (wg_isatom(db,cl)) return 0;  
  if (!(wg_ispair(db,cl) && wg_first(db,cl)==(pp->jsonstruct))) return 0;
  cl=wg_rest(db,cl);
  if (!wg_ispair(db,cl)) return 0;  
  fun=wg_first(db,cl);
  if (!wg_islog_uri(db,fun,"@include")) return 0;
  cl=wg_rest(db,cl);
  if (!wg_ispair(db,cl)) return 0; 
  return 1;
}


void* wr_process_json_import_clause(glb* g, void* mpool, void* cl, cvec clvec) {
  void* db=g->db;
  void* pathatom;
  char* str;
  char* filename=NULL;
  FILE* fp;
  int bytes;
  char* axiomfolder="/opt/TPTP/";
  char* envfolder=NULL;
  char *lastslash = NULL;
  //char *parent = NULL;
  char* p1;
  char* p2;
  char* str2;
  int askinfo=0;
  //int tmp;
 
#ifdef IDEBUG
  printf("\nwr_process_tptp_import_clause starts with\n");
  wg_mpool_print(db,cl); 
  printf("\n");
  printf("\nproblem filename is %s\n",g->filename);
#endif
  if (!(g->filename) || strlen(g->filename)<1) {
    wr_show_jsparse_error(g,NULL,"no filename given in wr_process_tptp_import_clause\n");
    return NULL;
  }
  pathatom=wg_nth(db,cl,2);
  envfolder=getenv("TPTP");
#ifdef IDEBUG
  //printf("\npathatom is\n");
  //wg_mpool_print(db,pathatom); 
  printf("\nTPTP env var value is %s\n",envfolder);
  printf("\n$TPTP env var value is  %s\n",getenv("$TPTP"));
  //wg_mpool_print(db,envfolder);
  //printf("\nwg_atomtype(db,pathatom) %d WG_URITYPE %d\n",wg_atomtype(db,pathatom),WG_URITYPE);
  //printf("\n");
#endif  
  if (wg_atomtype(db,pathatom)!=WG_URITYPE) return 0;  
  str=wg_atomstr1(db,pathatom); 
  if (str && str[0]=='#') str=str+1;
  lastslash=strrchr(g->filename,'/');
  if (lastslash!=NULL) {
    bytes=strlen(str)+strlen(g->filename)+10;
    str2=wg_alloc_mpool(db,mpool,bytes);
    if (!str2) return NULL;
    for(p1=(g->filename), p2=str2; p1<lastslash; p1++, p2++) {
      *p2=*p1;
    }
    *p2=(char)0;    
    strcat(str2,"/");
    strcat(str2,str);    
  } else {
    str2=str;
  }  
#ifdef IDEBUG
  //printf("\nstr %s\n",str);
  //printf("\nstr2 %s\n",str2);
  fp=fopen(str,"r");
  if (fp!=NULL) {
    printf("\nfile %s found\n",str); 
    fclose(fp);
  } else {
    printf("\nfile %s not found\n",str); 
  }  
  fp=fopen(str2,"r");
  if (fp!=NULL) {
    printf("\nfile %s found\n",str2); 
    fclose(fp);
  } else {
    printf("\nfile %s not found\n",str2); 
  }  
#endif
  //printf("\nfirst import path str2: %s\n",str2);  
  fp=fopen(str2,"r");
  if (fp!=NULL) {
    // succeeded to open axiom file: use that
    fclose(fp);
    filename=str2; 
  } else {
    if (envfolder) axiomfolder=envfolder;
    // failed to open axiom file: try env or default axiom folder
    bytes=strlen(str)+strlen(axiomfolder)+10;
    filename=wg_alloc_mpool(db,mpool,bytes);
#ifdef IDEBUG
    printf("\nalloced filename %s\n",filename);
#endif    
    if (!filename) {
      wr_show_jsparse_error(g,NULL,"cannot allocate filename in wr_process_tptp_import_clause\n");
      return NULL;
    }
    strcpy(filename,axiomfolder);
    if (envfolder) strcat(filename,"/");
    strcat(filename,str);
    //printf("\nsecond import path str: %s\n",filename);
  }
  //tmp=
#ifdef IDEBUG
  printf("\nfilename %s\n",filename);
#endif   
  if (wg_is_jsfile(db,filename)) {
    wr_import_js_file(g,filename,NULL,clvec,1,0, &askinfo, 0);
  } else {
    //(g->parser_print_level)=0;
    //(g->print_initial_parser_result)=0;
    //(g->print_generic_parser_result)=1;
    (dbmemsegh(db)->infrm_mpool)=wg_create_mpool(db,PARSER_MEMPOOL_SIZE); 
    //res=wr_import_otter_file(g,filename,NULL,NULL,iskb);
    if (g->parse_errmsg) {
      printf("%s\n",(g->parse_errmsg));
      sys_free(g->parse_errmsg);
      return NULL;
    } else if (dbmemsegh(db)->errflag) {
      wg_show_db_error(db);
      return NULL;
    }
    wr_import_otter_file(g,filename,NULL,clvec,1);
  }
  return NULL;
}


/* ------------ process normal json formula ------------------- */


void* wr_process_json_formula(glb* g,parse_parm* pp, void* cl, int isincluded) {  
  void* mpool=pp->mpool;
  void* db=g->db;
  //void* logconn;
  void *preres=NULL; 
  void *res, *name, *role, *content, *tmp, *origcl, *question;
  char *namestr=NULL, *rolestr=NULL;
  int blen=990,bpos=0;
  char namebuf[1000];
  char rolebuf[16];  

#ifdef DEBUG
  printf("\nwr_process_json_formula called with (pp->parse_top_level) %d\n",(pp->parse_top_level));
  wg_mpool_print(db,cl);
  printf("\n"); 
#endif
  if (pp->parse_top_level) {
    pp->formulaname=NULL;
    pp->formularole=NULL;
    pp->freevars=NULL;
    pp->freevarsnr=0;
    pp->nullvars=NULL;
    pp->nullvarsnr=0;
    pp->boundvars=NULL;
    pp->jsonld_ctxt=NULL;
    pp->jsonld_base=NULL;
  }
  name=NULL;
  role=NULL;
  if (cl==NULL) {
    preres=NULL;  
  } else {   
    // process keyval
    origcl=cl;
    if (wg_ispair(db,cl) && wg_first(db,cl)==(pp->jsonstruct)) {
      question=wg_get_keystrval(db, "@question", cl);
      if (question && (pp->parse_top_level)) {
        // handle the question special tag
        content=wg_get_keystrval(db, "@logic", cl);
        role=wg_get_keystrval(db, "@role", cl);
        if (content || role) {
          wr_show_jsparse_error(g,pp,
            "@question should not occur in the same formula as @logic or @role");
          return NULL;
        }
        // replace @question with @logic
        tmp=wg_get_keystrplace(db,"@question",cl);
        *((gint*)tmp)=(gint)(wg_mkatom(db,mpool,WG_URITYPE,"@logic",NULL));
        // add question @role        
        tmp=wg_mkpair(db,mpool,wg_mkatom(db,mpool,WG_URITYPE,"question",NULL),wg_rest(db,cl));
        tmp=wg_mkpair(db,mpool,wg_mkatom(db,mpool,WG_URITYPE,"@role",NULL),tmp);
        tmp=wg_mkpair(db,mpool,(pp->jsonstruct),tmp);
        cl=tmp;
        origcl=cl;       
      }
      // now process struct
      cl=wr_process_json_formula_struct(g,pp,cl,isincluded);
      if (!cl) return NULL;
      if (pp->parse_top_level) {
        name=wg_get_keystrval(db, "@name", origcl);
        role=wg_get_keystrval(db, "@role", origcl);      
      }  
      content=wg_get_keystrval(db, "@logic", cl);      
      if((name && !wg_isatom(db,name)) || (role && !wg_isatom(db,role))) {
        // err case
        wr_show_jsparse_error(g,pp,"formula @name and @role must be strings");
        return NULL;     
      } else {
        // ok case
        if (name) {    
          namestr=wg_atomstr1(db,name);        
          pp->formulaname=namestr;
        }  
        if (role) {
          rolestr=wg_atomstr1(db,role);          
          pp->formularole=rolestr;                         
        }  
        if (role && strcmp(rolestr,"axiom") && strcmp(rolestr,"assumption") &&
            strcmp(rolestr,"hypothesis") &&
            strcmp(rolestr,"conjecture") && strcmp(rolestr,"negated_conjecture")  &&
            strcmp(rolestr,"question")) {
            //strcmp(rolestr,"ask")) {
          wr_show_jsparse_error(g,pp,"unknown role value used");  
        } else if (content) {
          cl=content;
        } else if (role && !content) {
          //wr_show_jsparse_error(g,pp,"json object has a @role key but no @logic key value");   
        } else {
          //cl=NULL;        
        }      
      }
    }

    // here keyval is processed
#ifdef MARK_IMPORTED_NAMES             
    if (namestr && isincluded && strlen(namestr)<900) {
      strncpy(namebuf,IMPORTED_NAME_PREFIX,900);
      strncat(namebuf,namestr,900);
      namestr=namebuf;
      pp->formulaname=namestr;
      name=wg_mkatom(db,mpool,WG_URITYPE,pp->formulaname,NULL);
    }         
#endif      
    // process logic
    if (!(g->parse_errflag)) {
      preres=wr_process_json_formula_aux(g,pp,cl);      
      if (preres) {
        if ((pp->parse_top_level) && (pp->freevars)) {
          pp->freevars=wg_reverselist(db,mpool,pp->freevars);
        }
        if (role && !strcmp(rolestr,"question")) {

          //add negation like normally done, but keep freevars free

          pp->formularole="negated_conjecture";
          role=wg_mkatom(db,mpool,WG_URITYPE,pp->formularole,NULL);
          if (pp->freevars) {
            tmp=wg_mkatom(db,mpool,WG_URITYPE,"$ans",NULL);
            tmp=wg_mkpair(db,mpool,tmp,pp->freevars);
            tmp=wg_mklist3(db,mpool,pp->logimp,preres,tmp);
            preres=wg_mklist3(db,mpool,pp->logall,pp->freevars,tmp);
          } else {             
            preres=wg_mklist2(db,mpool,pp->logneg,preres);
          }
        } else if (role && !strcmp(rolestr,"ask")) {          
          pp->askinfo=1; //ask role was found 
          if (pp->askpolarity) {
            printf("\n * try to answer positively: add negation  \n");
            // try to answer positively: add negation like normally done, but keep freevars free
            pp->formularole="negated_conjecture";
            role=wg_mkatom(db,mpool,WG_URITYPE,pp->formularole,NULL);
            
            if (pp->freevars) {
              tmp=wg_mkatom(db,mpool,WG_URITYPE,"$ans",NULL);
              tmp=wg_mkpair(db,mpool,tmp,pp->freevars);
              tmp=wg_mklist3(db,mpool,pp->logimp,preres,tmp);
              preres=wg_mklist3(db,mpool,pp->logall,pp->freevars,tmp);
            } else {             
              preres=wg_mklist2(db,mpool,pp->logneg,preres);
            } 
          } else {               
            // try to answer negatively: do not add negation, yet keep freevars free
            printf("\n * try to answer negatively: do not add negation  \n");           
            pp->formularole="conjecture";
            role=wg_mkatom(db,mpool,WG_URITYPE,pp->formularole,NULL);
            if (pp->freevars) {              
              tmp=preres;
              preres=wg_mklist3(db,mpool,pp->logexists,pp->freevars,tmp);
              preres=wg_mklist2(db,mpool,pp->logneg,preres);
            } else {             
              preres=wg_mklist2(db,mpool,pp->logneg,preres);
            }                                            
          } 
        } else if (role && !strcmp(rolestr,"negated_conjecture")) {
          pp->formularole="negated_conjecture";  
          if (pp->freevars) preres=wg_mklist3(db,mpool,pp->logall,pp->freevars,preres);
        } else if (role && !strcmp(rolestr,"conjecture")) {
          pp->formularole="conjecture";  
          if (pp->freevars) {
            preres=wg_mklist3(db,mpool,pp->logall,pp->freevars,preres);
          }  
        } else if ((pp->freevars) && (pp->parse_top_level)) {
          preres=wg_mklist3(db,mpool,pp->logall,pp->freevars,preres);
        }
      }      
    }  
  }

  if (g->parse_errflag) {
    //printf("\n%s\n",g->parse_errmsg);
    return NULL;
  }
  
  if (!preres) return NULL;

  if (!name) {
    sprintf(namebuf,"frm_%d",pp->formulanr);
    name=wg_mkatom(db,mpool,WG_URITYPE,namebuf,NULL);
  } 
  if (!role) {
    sprintf(rolebuf,"axiom");
    role=wg_mkatom(db,mpool,WG_URITYPE,rolebuf,NULL);
  }  
  if (!name  || !role) {
    wr_show_jsparse_error(g,pp,"cannot make a clause name or role");
    return NULL;
  }
  if (pp->parse_top_level) {
    preres=wg_mklist4(db,mpool,NULL,name,role,preres);
  }  
 
#ifdef DEBUG
  printf("\nwr_process_json_formula preres is\n");
  wg_mpool_print(db,preres);
  printf("\n");  

  printf("\nwr_process_json_formula freevars is\n");
  wg_mpool_print(db,pp->freevars);
  printf("\n");  

  printf("\nwr_process_json_formula boundvars is\n");
  wg_mpool_print(db,pp->boundvars);
  printf("\n");  

  printf("\nwr_process_json_formula nullvars is\n");
  wg_mpool_print(db,pp->nullvars);
  printf("\n");  

  printf("\nwr_process_json_formula ctxt is\n");
  wg_mpool_print(db,pp->jsonld_ctxt);
  printf("\n");  
   
  printf("\nbefore wr_preprocess_tptp_fof_clause\n");
  wg_mpool_print(db,preres);
  printf("\n");
#endif   
  
  if ((pp->parse_top_level) && (dbmemsegh(db)->convert) && (dbmemsegh(db)->tptp)) {
    // conversion to tptp
    bpos=0;   
    if (!namestr) {     
      sprintf(namebuf,"frm_%d",pp->formulanr);
      namestr=namebuf;
    }
    if (!rolestr) {
      rolestr="axiom";
    } else if (!strcmp(rolestr,"question")) {
      rolestr="negated_conjecture";
    }
    if (namestr && wg_should_quote(namestr)) {
      bpos+=snprintf((g->tmp_printbuf)+bpos,blen-bpos,"fof('%s',%s,",namestr,rolestr);
    } else {
      bpos+=snprintf((g->tmp_printbuf)+bpos,blen-bpos,"fof(%s,%s,",namestr,rolestr);
    }  
    /*
    printf("\npreres before\n");
    wg_mpool_print(db,preres);
    printf("\npreres after\n");
    */
    wg_expand_frm_for_print(db,mpool,preres);
    /*
    wg_mpool_print(db,preres);
    printf("\n"); 
    */
    bpos=wg_print_frm_tptp(db,wg_nth(db,preres,3),&(g->tmp_printbuf),&blen,bpos); 
    if (!wr_str_guarantee_space(g,&(g->tmp_printbuf),&blen,bpos+100)) {
      if (g->tmp_printbuf) wr_free(g,(g->tmp_printbuf));
      return NULL;
    }
    bpos+=snprintf((g->tmp_printbuf)+bpos,blen-bpos,").\n");
    printf("%s",(g->tmp_printbuf));
  }
  if ((pp->parse_top_level) && !((dbmemsegh(db)->convert) && (dbmemsegh(db)->tptp))) {
    // not conversion to tptp    
    preres=wr_preprocess_tptp_fof_clause(g,mpool,preres,NULL);    
  }

#ifdef DEBUG  
  printf("\nafter wr_preprocess_tptp_fof_clause\n");
  wg_mpool_print(db,preres);
  printf("\n");
#endif
  if (pp->parse_top_level) {
    res=wg_mklist3(db,mpool,name,role,preres);
  } else { 
    res=preres;
  }  
  //res=wg_mklist4(db,mpool,name,role,preres,origcl);

#ifdef DEBUG
  printf("\nwr_process_json_formula result is\n");
  wg_mpool_print(db,res);
  printf("\n");
#endif  
  return res;
}


void* wr_process_json_formula_aux(glb* g, parse_parm* pp, void* cl) {
  void* mpool=pp->mpool;
  void* db=g->db;
  void* preres=NULL;
  void *res, *head, *logconn, *newlogconn;
  void *r1, *r2, *r1el, *r2el; 
  void *r1proc, *r2proc;
  void *content=NULL; // *name,
  char* str; 
  int isneg,isreverse;

#ifdef DEBUG
  printf("\nwr_process_json_formula_aux called\n");
  wg_mpool_print(db,cl);
  printf("\n");
#endif
  if (cl==NULL) {
    return NULL;
  } 
  // process keyval
  if (wg_ispair(db,cl) && wg_first(db,cl)==(pp->jsonstruct)) {
    //name=wg_get_keystrval(db, "name", cl);
    cl=wr_process_json_formula_struct(g,pp,cl,0);
    //res=wr_process_json_formula_keyextend(g,pp,NULL,cl,0);
    //return res;    
    if (!cl) return NULL;
    content=wg_get_keystrval(db, "@logic", cl);
    if (content) {
      return wr_process_json_formula_aux(g,pp,content);
    } else {
      wr_show_jsparse_error(g,pp,"json object has no @logic key value");
      return NULL;
    }    
  }
#ifdef DEBUG
  printf("\nin wr_process_json_formula_aux after keyval processing cl:\n");
  wg_mpool_print(db,cl);
  printf("\n");
  printf("\nin wr_process_json_formula_aux after keyval processing content:\n");
  wg_mpool_print(db,content);
  printf("\n");
#endif
  // now cl is not a keyval
  if (cl==NULL) {
    preres=NULL;
  } else if (wg_isatom(db,cl)) {
    if (cl==pp->jsonnull) {
      wr_show_jsparse_error(g,pp,"null can be used only inside an atom, not at the formula level");
      return NULL;
    }   
    // negated atom?        
    if ((wg_atomtype(db,cl)==WG_URITYPE && cl!=pp->logfalse && cl!=pp->logtrue) &&
        wg_atomstr1(db,cl) &&
        ((wg_atomstr1(db,cl))[0]=='-' ||
         (wg_atomstr1(db,cl))[0]=='~')) {                      
      if (wg_atomstr1(db,cl)[1]=='-' || (wg_atomstr1(db,cl))[0]=='~') {
        wr_show_jsparse_error(g,pp,
          "double negation character like -- or ~~ prohibited in logical symbols");
        return NULL;
      }
      r1=wg_mkatom(db,mpool,WG_URITYPE,(wg_atomstr1(db,cl)+1),NULL);            
      cl=wg_mklist2(db,mpool,pp->logneg,r1);
      if (!r1 || !cl) {
        wr_show_jsparse_error(g,pp,"cannot process neg atom: memory overflow");
        return NULL;
      }    
      preres=wr_process_json_formula_aux(g,pp,cl);      
    } else {      
      preres=wr_process_json_term(g,pp,cl,1,0);
    }    
  } else {
    // get main parts
    head=wg_first(db,cl);       
    r1=wg_rest(db,cl);
    if (r1!=NULL) {
      r1el=wg_first(db,r1);
      r2=wg_rest(db,r1);    
    } else {
      r1el=NULL;
      r2=NULL;
    }  
    // process logical structure
    logconn=wr_json_list_logconn(g,pp,cl);
    if (head==NULL) {
      wr_show_jsparse_error(g,pp,"null value at the head of a logical list");
      return NULL;
    } else if (wg_isatom(db,head) && !strcmp("and",wg_atomstr1(db,head)) && !r1) {
      preres=wg_makelogfalse(db,mpool);          
    } else if (wg_isatom(db,head) && !strcmp("or",wg_atomstr1(db,head)) && !r1) {
      preres=wg_makelogtrue(db,mpool); 
    } else if (wr_json_is_eq_op(g,r1el) && head && wg_ispair(db,r2)) {      
      str=wg_atomstr1(db,r1el);
      if (*str!='=') {
        // not a positive equality, hence negative
        head=wr_process_json_term(g,pp,head,0,1);
        r2el=wr_process_json_term(g,pp,wg_first(db,r2),0,2);
        preres=wg_mklist2(db,mpool,
                wg_makelogneg(db,mpool), 
                wg_mklist3(db,mpool,
                  wg_makeatomeq(db,mpool),
                  head,
                  r2el));
      } else {
        // a positive equality
        head=wr_process_json_term(g,pp,head,0,1);
        r2el=wr_process_json_term(g,pp,wg_first(db,r2),0,2);
        preres=wg_mklist3(db,mpool,r1el,head,r2el);
      }  
    } else if (wg_isatom(db,head) &&
               (!strcmp("not",wg_atomstr1(db,head)) ||
                !strcmp("-",wg_atomstr1(db,head)) ||
                !strcmp("~",wg_atomstr1(db,head)) )) {  
      // negation               
      if (r1==NULL) {
        wr_show_jsparse_error(g,pp,"not enough arguments for not connective");
        return NULL;
      }          
      if (r2!=NULL) {
        wr_show_jsparse_error(g,pp,"too many arguments for not connective");
        return NULL;
      }      
      r1proc=wr_process_json_formula_aux(g,pp,r1el);
      if (r1proc==NULL) return NULL;
      *((gint*)cl)=(gint)(pp->logneg);
      *((gint*)r1)=(gint)r1proc;
      preres=cl;      
    } else if (wg_isatom(db,head) && !strcmp("exists",wg_atomstr1(db,head))) {      
      if (r1==NULL) {
        wr_show_jsparse_error(g,pp,"not enough arguments for exists connective");
        return NULL;
      }
      if (!wr_json_is_atomlist(db,r1el)) {
        wr_show_jsparse_error(g,pp,"first argument of exists connective not a variable list");
        return NULL;
      }    
      if (r2==NULL) {
        wr_show_jsparse_error(g,pp,"not enough arguments for exists connective");
        return NULL;
      }
      if (wg_rest(db,r2)!=NULL) {
        wr_show_jsparse_error(g,pp,"too many arguments for exists connective");
        return NULL;
      }
      (pp->boundvars)=wg_mkpair(db,mpool,r1el,(pp->boundvars));
      r2proc=wr_process_json_formula_aux(g,pp,wg_first(db,r2));
      (pp->boundvars)=wg_rest(db,(pp->boundvars));
      if (r2proc==NULL) return NULL;
      *((gint*)cl)=(gint)(pp->logexists);
      *((gint*)r2)=(gint)r2proc;
      preres=cl;
    } else if (wg_isatom(db,head) && !strcmp("forall",wg_atomstr1(db,head))) {      
      if (r1==NULL) {
        wr_show_jsparse_error(g,pp,"not enough arguments for forall connective");
        return NULL;
      }
      if (!wr_json_is_atomlist(db,r1el)) {
        wr_show_jsparse_error(g,pp,"first argument of forall connective not a variable list");
        return NULL;
      }      
      if (r2==NULL) {
        wr_show_jsparse_error(g,pp,"not enough arguments for forall connective");
        return NULL;
      }
      if (wg_rest(db,r2)!=NULL) {
        wr_show_jsparse_error(g,pp,"too many arguments for forall connective");
        return NULL;
      }
      (pp->boundvars)=wg_mkpair(db,mpool,r1el,(pp->boundvars));             
      r2proc=wr_process_json_formula_aux(g,pp,wg_first(db,r2));
      (pp->boundvars)=wg_rest(db,(pp->boundvars));
      if (r2proc==NULL) return NULL;
      *((gint*)cl)=(gint)(pp->logall);
      *((gint*)r2)=(gint)r2proc;
      preres=cl;
    } else if (wg_isatom(db,head) && !strcmp("if",wg_atomstr1(db,head))) {
      preres=wr_json_process_if_then(g,pp,cl);   
    } else if (logconn!=NULL) {
      // contains logical stuff at top
      preres=wg_inplace_reverselist(db,mpool,cl);
#ifdef DEBUG      
      printf("\nwr_process_json_formula_aux reverse result is\n");
      wg_mpool_print(db,preres);
      printf("\n");
#endif      
      newlogconn=wr_json_translate_connective(g,pp,logconn);
      isneg=wr_json_negtype_connective(g,pp,logconn);
      if (wg_isatom(db,logconn) && !strcmp("<=",wg_atomstr1(db,logconn))) isreverse=1;
      else isreverse=0;
#ifdef DEBUG      
      printf("\nwr_process_json_formula_aux before unflatten  is\n");
      wg_mpool_print(db,preres);
      printf("\n");
#endif         
      preres=wr_json_unflatten_logic(g,pp,preres,logconn,newlogconn,!isneg,isreverse);   
#ifdef DEBUG      
      printf("\nwr_process_json_formula_aux unflatten result is\n");
      wg_mpool_print(db,preres);
      printf("\n");
#endif      
    } else if (wg_ispair(db,head)) {     
      newlogconn=MKWGURILEN(pp,"or",2);
      preres=wg_mkpair(db,mpool,newlogconn,cl); 
      preres=wr_process_json_formula_aux(g,pp,preres);      
    } else {     
      preres=wr_process_json_term(g,pp,cl,1,0);
    }
  }
  res=preres; 
#ifdef DEBUG  
  printf("\nwr_process_json_formula_aux result is\n");
  wg_mpool_print(db,res);
  printf("\n");
#endif
  return res;
}


/* ------- process keys for json-ld ------------------- */


void* wr_process_json_formula_struct(glb* g, parse_parm* pp, 
        void* cl, int isincluded) {
  void* mpool=pp->mpool;
  void* db=g->db;
  char *keystr; 
  void *part, *tmp, *key, *keyval;
  void *origid, *id=NULL;
  void* extended=NULL;
  void *name, *role, *logic, *graph, *question, *ctxt;
  int tmpval;
  void *graphel, *resultclause;
  int foundkey;
  gint array[12];
  
#ifdef EXPAND_JSONLD_KEYS   
  char *modkeystr;
  int buflen=1000;
  char keybuf[1000];
#endif  


#ifdef DEBUG 
  printf("\nwr_process_json_formula_struct called for \n");
  wg_mpool_print(db,cl);
  printf("\n");
#endif 
  if (!cl) return NULL;
  if (!wg_rest(db,cl)) return NULL;
  // cl must be keyval
  // find id if present
  origid=wg_get_keystrval(db,"@id",cl);   
  name=wg_get_keystrval(db,"@name",cl);
  role=wg_get_keystrval(db,"@role",cl);
  graph=wg_get_keystrval(db,"@graph",cl);
  logic=wg_get_keystrval(db,"@logic",cl);
  question=wg_get_keystrval(db,"@question",cl);
  if ((role || question) && !(pp->parse_top_level)) {
    wr_show_jsparse_error(g,pp,"@role or @question should not be used inside a nested object");
    return NULL;
  }
  // get and process context
  ctxt=wg_get_keystrval(db,"@context",cl); 
  tmpval=wr_json_extend_context(g,pp,ctxt);  
  if (tmpval<0) return NULL; // error in context
  if (origid) id=wr_json_mkid(g,mpool,pp,origid,NULL);
  foundkey=0;
  if (graph && !origid) {
    // detect if there are keys    
    for (part=wg_rest(db,cl); part!=NULL; part=wg_rest(db,part)) {
      key=wg_first(db,part);
      keystr=wg_atomstr1(db,key);
      if (key && !(wr_json_special_keystr(g, keystr))) {
        foundkey=1;
        break;
      }      
      part=wg_rest(db,part);
      continue;
    }      
  }
  // loop over all keys
  for(part=wg_rest(db,cl); wg_ispair(db,part); part=wg_rest(db,part)) {
    key=wg_first(db,part);
    if (!wg_isatom(db,key) || wg_atomtype(db,key)!=WG_URITYPE) {
      part=wg_rest(db,part);
      continue;
    }  
    tmp=wg_rest(db,part);
    keystr=wg_atomstr1(db,key);
    if (wg_ispair(db,tmp)) {
      keyval=wg_first(db,tmp);
    } else {
      keyval=NULL;
    }
    // here we have keystr and keyval
    if (!(wr_json_special_keystr(g, keystr))) {
      // normal key, not a special @-prefixed key
#ifdef EXPAND_JSONLD_KEYS      
      modkeystr=wg_modify_keystr_by_ctxt(g,pp,keybuf,buflen,keystr);
      if (modkeystr!=keystr) {
        if (!modkeystr) keystr=keybuf;
        else keystr=modkeystr;
      } 
#endif       
      if (!id) {               
        id=wr_json_mkid(g,mpool,pp,origid,NULL);      
      }        
      extended=wr_add_struct_key_atoms(g,pp,id,keystr,keyval,extended);             
    } else if (!strcmp("@type",keystr)) {
      if (!id) {               
        id=wr_json_mkid(g,mpool,pp,origid,NULL);      
      }       
#ifdef EXPAND_JSONLD_KEYS       
      keyval=wr_json_expand_list_prefixes(g,mpool,pp,keyval,0);      
#endif      
      extended=wr_add_struct_key_atoms(g,pp,id,
          wg_atomstr1(db,pp->jsonld_typerepl),keyval,extended);
    } else if (!strcmp("@graph",keystr)) {
      if (origid || foundkey) {
        if (!id) {               
          id=wr_json_mkid(g,mpool,pp,origid,NULL);      
        }         
      }        
      for (part=keyval; part!=NULL; part=wg_rest(db,part)) {
        graphel=wg_first(db,part);
        //tmpval=(pp->parse_top_level);
        wr_json_push_context(g,pp,array);
        (pp->parse_top_level)=0;
        (pp->jsonld_graphid)=id;        
        resultclause=wr_process_json_formula(g,pp,graphel,1);   
        wr_json_pop_context(g,pp,array);
        //(pp->parse_top_level)=tmpval;
        extended=wr_json_add_with_and(g,pp,resultclause,extended);               
      }      
    }
    // continue to next key
    if (wg_ispair(db,tmp)) {
      part=tmp;
    } else {
      break;
    }
  }
  // here we could have logic and extended or only one or none of them
  if (!extended) {
    cl=logic;    
    // wrap into a structure with @logic   
    tmp=wg_mklist2(db,mpool,      
      wg_mkatom(db,mpool,WG_URITYPE,"@logic",NULL), 
      logic);
    cl=wg_mkpair(db,mpool,
        wg_mkatom(db,mpool,WG_URITYPE,MPOOL_STRUCT_PREFSTR,NULL),
        tmp);  
  } else {   
    // extended is present    
    //extended=wr_process_json_formula_aux(g,pp,extended); //,0,1);  
    if (logic) {     
      // both extended and logic part present        
      if (role && (!strcmp(wg_atomstr1(db,role),"question") ||
         !strcmp(wg_atomstr1(db,role),"conjecture"))) {
        logic=wr_json_add_with_negated_or(g,pp,logic,extended);
      } else {         
        logic=wr_json_add_with_and(g,pp,logic,extended);       
      }             
    } else {
      // no logic part present
      logic=extended;
    }  
    // wrap into a structure with @logic
    tmp=wg_mklist2(db,mpool,      
      wg_mkatom(db,mpool,WG_URITYPE,"@logic",NULL), 
      logic);
    if (role) {
      tmp=wg_mkpair(db,mpool,
        wg_mkatom(db,mpool,WG_URITYPE,"@role",NULL),
        wg_mkpair(db,mpool, 
          role,
          tmp));
    }
    if (name) {
      tmp=wg_mkpair(db,mpool,
        wg_mkatom(db,mpool,WG_URITYPE,"@name",NULL),
        wg_mkpair(db,mpool, 
          name,
          tmp));
    }
    cl=wg_mkpair(db,mpool,
        wg_mkatom(db,mpool,WG_URITYPE,MPOOL_STRUCT_PREFSTR,NULL),
        tmp); 
  }
#ifdef DEBUG        
  printf("\n final fully made extended+logic cl ");
  wg_mpool_print(db,cl);
  printf("\n");    
#endif    
  return cl; 
}

void* wr_add_struct_key_atoms(glb* g, parse_parm* pp, 
         void* id, char* keystr, void* values, void* extended) {
  void* mpool=pp->mpool;
  void* db=g->db;
  void *el, *atom, *part, *list, *value, *neworigid, *newid, *resultclause;
  void *res1; 
  char* valstr;
  void* modvalue=NULL;
  gint array[12];


#ifdef DEBUG 
  printf("\nwr_add_struct_key_atoms called on keystr %s and values:\n",keystr);
  wg_mpool_print(db,values);
  printf("\nid:\n");
  wg_mpool_print(db,id);
  printf("\n");
#endif
  if (!wg_ispair(db,values)) {
    // simple value
    if (values==pp->jsonnull) {
      return extended;
    }  
    if (values && wg_atomtype(db,values)==WG_URITYPE) {                  
      if (wr_json_isvar(g,pp,values)) {
        modvalue=values;
      } else {
        valstr=wg_atomstr1(db,values);
        modvalue=wg_mkatom(db,mpool,WG_ANONCONSTTYPE,valstr,NULL);
      }  
    } else {
      modvalue=values;
    }  
    atom=wr_json_mkarc(db,pp,
        id,wg_mkatom(db,mpool,WG_URITYPE,keystr,NULL),modvalue);
    extended=wr_json_add_with_and(g,pp,atom,extended);  
  } else if (wg_first(db,values)==(pp->jsonstruct)) {
    // value is a structure
    if (!wg_ispair(db,wg_rest(db,values))) return extended;

    list=wg_get_keystrval(db, "@list", values);
    if (!list) list=wg_get_keystrval(db, "@set", values);
    value=wg_get_keystrval(db, "@value", values);
    if (value && wg_atomtype(db,value)==WG_URITYPE) {
      valstr=wg_atomstr1(db,value);
      modvalue=wg_mkatom(db,mpool,WG_ANONCONSTTYPE,valstr,NULL);
    } else {
      modvalue=value;
    } 
    if (list) {
      // list structure case
      if (wg_isatom(db,list) && !strcmp("$nil",wg_atomstr1(db,list)))
        res1=list;
      else
        res1=wr_process_json_list(g,pp,list);
      atom=wr_json_mkarc(db,pp,
        id,wg_mkatom(db,mpool,WG_URITYPE,keystr,NULL),res1);
      extended=wr_json_add_with_and(g,pp,atom,extended);  
    } else if (modvalue) {
      // @value object
      atom=wr_json_mkarc(db,pp,
        id,wg_mkatom(db,mpool,WG_URITYPE,keystr,NULL),modvalue);
      extended=wr_json_add_with_and(g,pp,atom,extended);   
    } else {
      // nested structure case
      neworigid=wg_get_keystrval(db,"@id",values); 
      if (neworigid) {
        newid=wr_json_mkid(g,mpool,pp,neworigid,values); //neworigid;         
      } else {
        newid=wr_json_mkid(g,mpool,pp,NULL,NULL);     
        values=wr_add_keyval_jsstruct(g,pp, 
          wg_mkatom(db,mpool,WG_URITYPE,"@id",NULL),
          newid,
          values);
      }  
      atom=wr_json_mkarc(db,pp,
        id,wg_mkatom(db,mpool,WG_URITYPE,keystr,NULL),newid);
      res1=wr_json_add_with_and(g,pp,atom,extended); 
      wr_json_push_context(g,pp,array);
      pp->parse_top_level=0;      
      resultclause=wr_process_json_formula(g,pp,values,0);  
      wr_json_pop_context(g,pp,array); 
      if (resultclause){        
        extended=wr_json_add_with_and(g,pp,resultclause,res1); 
      } else {
        extended=res1;
      }
  #ifdef DEBUG     
      printf("\ncombined extended:\n");
      wg_mpool_print(db,extended);
      printf("\ncombined done\n");
  #endif    
    }
  } else {
    // value is a list to be looped over
    for(part=values; wg_ispair(db,part); part=wg_rest(db,part)) {
      el=wg_first(db,part);
      extended=wr_add_struct_key_atoms(g,pp,id,keystr,el,extended);
    }      
  }
  return extended;
}

void* wr_json_mkarc(glb* g, parse_parm *pp, void* id, void* pred, void* obj) {
  void* res;
  
  if (pp->jsonld_graphid) {
    res=wg_mklist5(g->db,pp->mpool,
          wg_mkatom(g->db,pp->mpool,WG_URITYPE,MPOOL_JSON_NARC,NULL),
          id, pred, obj, pp->jsonld_graphid);
  } else {  
    res=wg_mklist4(g->db,pp->mpool,
          wg_mkatom(g->db,pp->mpool,WG_URITYPE,MPOOL_JSON_ARC,NULL),
          id, pred, obj);
  }
  return res;      
}

void wr_json_push_context(glb* g, parse_parm *pp, gint* array) {
  *(array+0)=(gint)(pp->formulaname);
  *(array+1)=(gint)(pp->formularole);
  *(array+2)=(gint)(pp->freevars);
  *(array+3)=(gint)(pp->freevarsnr);
  *(array+4)=(gint)(pp->nullvars);
  *(array+5)=(gint)(pp->nullvarsnr);
  *(array+6)=(gint)(pp->boundvars);
  *(array+7)=(gint)(pp->jsonld_ctxt);
  *(array+8)=(gint)(pp->jsonld_base);
  *(array+9)=(gint)(pp->parse_top_level);
  *(array+10)=(gint)(pp->jsonld_graphid);
}

void wr_json_pop_context(glb* g, parse_parm *pp, gint* array) {
  (pp->formulaname)=(char*)*(array+0);
  (pp->formularole)=(char*)*(array+1);
  (pp->freevars)=(void*)*(array+2);
  (pp->freevarsnr)=(int)*(array+3);
  (pp->nullvars)=(void*)*(array+4);
  (pp->nullvarsnr)=(int)*(array+5);
  (pp->boundvars)=(void*)*(array+6);
  (pp->jsonld_ctxt)=(void*)*(array+7);
  (pp->jsonld_base)=(void*)*(array+8);
  (pp->parse_top_level)=(int)*(array+9);
  (pp->jsonld_graphid)=(void*)*(array+10);
}

void* wr_json_expand_list_prefixes(glb* g, void* mpool, parse_parm* pp, void* lst, int depth) {
  void* db=g->db;
  void* res=NULL;
  void *part, *el, *ctxt, *tmp, *keyval;
  char *valstr, *modvalstr;
  int buflen=1000;
  char keybuf[1000];

  ctxt=pp->jsonld_ctxt;
  if (!ctxt) return lst;
  if (wg_isatom(db,lst)) {
    // lst is an atom, not a real list
    if (wg_atomtype(db,lst)==WG_URITYPE) {
      keyval=lst;
#ifdef EXPAND_JSONLD_LISTKEYS      
      valstr=wg_atomstr1(db,lst);
      modvalstr=wg_modify_keystr_by_ctxt(g,pp,keybuf,buflen,valstr);
      if (modvalstr!=valstr) {
        if (!modvalstr) valstr=keybuf;
        else valstr=modvalstr;
        keyval=wg_mkatom(db,mpool,WG_URITYPE,valstr,NULL);          
      } 
#endif      
      return keyval;
    } else {
      return lst;
    }
  } 
  // now lst is a real list
  for(part=lst; part!=NULL; part=wg_rest(db,part)) {
    el=wg_first(db,part);
    tmp=wr_json_expand_list_prefixes(g,mpool,pp,el,depth);
    res=wg_mkpair(db,mpool,tmp,res);
  } 
  return res;      
}
     

void* wr_json_mkid(glb* g, void* mpool, parse_parm* pp, void* givenid, void* map) {
  void* db=g->db;
  void* res;
  char *str, *basestr;
  void *base, *tmp;
  //void* ids=pp->jsonld_blanks;
  //int bpos;
  int len;
  int buflen=1000;
  char buf[1000];
  /*
  printf("\n base \n");
  wg_mpool_print(db,pp->jsonld_base);
  printf("\n");
  */
  if (givenid) {    
    str=wg_atomstr1(g->db,givenid);
    if (!str) return NULL;
    if (*str=='_' && *(str+1)==':') {
      // blank node
      res=givenid;
    } else if (wr_json_isvar(g,pp,givenid)) {
      res=givenid;
    } else {
      // not a blank node or a var
      base=pp->jsonld_base; // default base
      if (map) {
        // try to use the new map to get base
        tmp=wg_get_keystrval(db,"@context",map);
        if (tmp && wg_ispair(db,tmp)) {
          tmp=wg_get_keystrval(db,"@base",tmp);
          if (tmp) {
            // now use the new base
            base=tmp;
          }  
        }
      }             
      // try to use base   
      if (base && wg_isatom(db,base) &&
          wg_atomtype(db,base)==WG_URITYPE &&
          wg_atomstr1(db,base)) {
        // try to use base    
        basestr=wg_atomstr1(db,base);    
        len=strlen(basestr);
        if (wr_json_is_expandable_uristr(g,str) &&
            len &&  wg_suitable_context_uri_end(db,*(basestr+len-1))) {               
          if ((len+strlen(str)+10)>buflen) {
            wr_show_parse_error(g,"@base key value + key is too long"); 
            return wg_mkatom(db,mpool,WG_ANONCONSTTYPE,buf,NULL);
          }
          strcpy(buf,basestr);
          strcat(buf,str);         
          res=wg_mkatom(db,mpool,WG_ANONCONSTTYPE,buf,NULL);
        } else {
          res=wg_mkatom(db,mpool,WG_ANONCONSTTYPE,str,NULL);
        }  
      } else {                 
        // no base
        res=wg_mkatom(db,mpool,WG_ANONCONSTTYPE,str,NULL); 
      }  
    }
  } else {    
    // NULL givenid, make a new one   
    sprintf(buf,"_:crtd_%d",
      //wg_atomstr1(db,pp->jsonld_blankprefatom),
      (dbmemsegh(db)->parse_json_blankseed));
    (dbmemsegh(db)->parse_json_blankseed)++;
    res=wg_mkatom(db,mpool,WG_ANONCONSTTYPE,buf,NULL);                 
  }  
  return res;
}

int wr_json_special_keystr(glb* g, char* keystr) {
  int len;

  if (!keystr) return 1;  
  len=strlen(keystr);
  if (!len) return 1;  
  if (*keystr!='@') return 0;
  if (len>10) return 0;
  if (len<3) return 0;  
  if (!strcmp(keystr,"@id")) return 1;
  if (!strcmp(keystr,"@type")) return 1; 
  if (!strcmp(keystr,"@list")) return 1;
  if (!strcmp(keystr,"@set")) return 1;
  if (!strcmp(keystr,"@context")) return 1; 
  if (!strcmp(keystr,"@graph")) return 1; 
  if (!strcmp(keystr,"@name")) return 1;
  if (!strcmp(keystr,"@role")) return 1;
  if (!strcmp(keystr,"@logic")) return 1; 
  return 0;
}

int wr_json_special_logicstr(glb* g, char* keystr) {
  int len;

  if (!keystr) return 1;  
  len=strlen(keystr);
  if (!len) return 1;      
  if (*keystr=='?' && *(keystr+1)==':') return 1;
  if (*keystr=='_' && *(keystr+1)==':') return 1;
  if (len>10) return 0; 
  if (!strcmp(keystr,"=")) return 1;
  if (!strcmp(keystr,"$arc")) return 1; 
  if (!strcmp(keystr,"$narc")) return 1; 
  if (!strcmp(keystr,"$ans")) return 1; 
  if (!strcmp(keystr,"$list")) return 1;
  if (!strcmp(keystr,"$first")) return 1;
  if (!strcmp(keystr,"$rest")) return 1;  
  return 0;
}


int wr_json_freevarstr(glb* g, char* keystr) {
  int len;

  if (!keystr) return 0;  
  len=strlen(keystr);
  if (!len) return 0;   
  if (*keystr=='?' && *(keystr+1)==':') return 1;
  //if (*keystr=='_' && *(keystr+1)==':') return 1; 
  return 0;
}

int wr_json_isvar(glb* g, parse_parm* pp, void* atom) {
  void* db=g->db;
  char *str;

  if (!wg_isatom(db,atom)) return 0;  
  if (wg_atomtype(db,atom)!=WG_URITYPE) return 0;
  str=wg_atomstr1(db,atom);    
  if (*str=='?' && *(str+1)==':') return 1;
  if (wg_list_memberuri_in_sublist(db,(pp->boundvars),atom)) return 1;
  if (wg_list_memberuri_in_sublist(db,(pp->freevars),atom)) return 1; 
  return 0;
}

void* wr_process_json_term(glb* g, parse_parm* pp, void* cl, int atomlevel, int pos) {
  void* mpool=pp->mpool;
  void* db=g->db;
  void* preres=NULL;  
  void *content, *head, *list;
  void *a1, *a2;  
  void *r1, *r2,  *r1el; 
  void *tmp, *part; 
  int n, found;  
  char *valstr, *modvalstr; 
  int modified;
  int buflen=1000;
  char keybuf[1000];

  //char* str;

#ifdef DEBUG
  printf("\nwr_process_json_term called atomlevel %d\n",atomlevel);
  wg_mpool_print(db,cl);
  printf("\nboundvars:\n");
  wg_mpool_print(db,pp->boundvars);
  printf("\n");
#endif 
  if (atomlevel) {
    pp->nullvars=NULL;
    pp->nullvarsnr=0;
  } 
  // process keyval
  if (wg_ispair(db,cl) && wg_first(db,cl)==(pp->jsonstruct)) {
    //name=wg_get_keystrval(db, "name", cl);
    content=wg_get_keystrval(db, "@logic", cl);
    if (content) {
      return wr_process_json_term(g,pp,content,atomlevel,pos);
    } else {
      if (!atomlevel) {
        list=wg_get_keystrval(db, "@list", cl);
        if (!list) list=wg_get_keystrval(db, "@set", cl);
      }  
      else list=NULL;
      if (!list) {
        wr_show_jsparse_error(g,pp,"json object has neither @logic nor @list key value");
        return NULL;
      } else {
        if (wg_isatom(db,list) && !strcmp("$nil",wg_atomstr1(db,list)))
          cl=list;
        else
          cl=wr_process_json_list(g,pp,list);
      }
    }
  }
  // now cl is not a keyval
  if (cl==NULL) {
    preres=NULL;
  } else if (wg_isatom(db,cl)) {  
    if (cl==pp->jsonnull) {     
      if (atomlevel) {
        wr_show_jsparse_error(g,pp,"null can be used only inside an atom, not at the formula level");
        return NULL;
      }
      if (!pos) {
        wr_show_jsparse_error(g,pp,"first element of a list must be a symbol, not null");
        return NULL;
      }     
      a1=wr_json_make_nullvar(g,pp);
      if (!a1) return NULL;
      pp->nullvars=wg_mkpair(db,mpool,a1,pp->nullvars);
      return a1;
    } else if (!wg_atomstr1(db,cl) || !(wg_atomstr1(db,cl)[0])) {      
      preres=wg_mkatom(db,mpool,WG_ANONCONSTTYPE,"$emptystr",NULL);
    } else if (wg_atomtype(db,cl)!=WG_URITYPE && wg_atomtype(db,cl)!=WG_ANONCONSTTYPE && 
              cl!=pp->logfalse && cl!=pp->logtrue) {
      // not an uri
      if (!pos) {
        wr_show_jsparse_error(g,pp,"first element of a list must be a symbol, not a number");
        return NULL;
      }      
      preres=cl;
    } else if (//!atomlevel && pos && 
               wr_is_json_freevar(g,pp,cl)) {
      // variable case     
      if (!wg_list_memberuri(db,(pp->freevars),cl)) {
        found=0;
        for(part=(pp->boundvars); part!=NULL; part=wg_rest(db,part)) {          
          if (wg_list_memberuri(db,wg_first(db,part),cl)) {
            found=1;
            break;
          }
        }
        if (!found) (pp->freevars)=wg_mkpair(db,mpool,cl,(pp->freevars));
      }
      preres=cl; 
    } else if (//!atomlevel && pos && 
               wg_list_memberuri_in_sublist(db,(pp->boundvars),cl)) {
      // bound variable case           
      preres=cl;     
    } else if (!strcmp(wg_atomstr1(db,cl),wg_atomstr1(db,pp->jsonld_typekey))) {
      preres=pp->jsonld_typerepl;
    } else if (wg_atomtype(db,cl)==WG_URITYPE) { 
        
      
      valstr=wg_atomstr1(db,cl);
      modified=0;
#ifdef EXPAND_JSONLD_TERMS      
      // use context to change uri string valstr as necessary        
      if (//wr_json_is_expandable_uristr(g,valstr) &&
          !(wr_json_special_keystr(g, valstr)) &&
          !(wr_json_special_logicstr(g, valstr))) {
        modvalstr=wg_modify_keystr_by_ctxt(g,pp,keybuf,buflen,valstr);
        if (modvalstr!=valstr) {
          modified=1;
          if (!modvalstr) { 
            valstr=keybuf;            
          } else {
            valstr=modvalstr;                               
          }
        } 
      }
#endif       
      // now check if valstr starts with capital letter: if yes, make anonconst
      //printf("\n valstr %s modified %d\n",valstr,modified);
      if (wr_json_freevarstr(db,valstr)) {
        printf("\n valstr %s modified %d\n",valstr,modified);
        preres=cl; 
      } else if (1) { //(wr_is_parse_varstr(g,valstr)) { //(*str && (*str >= 'A') && (*str <= 'Z')) {
        // starts with a capital letter, make anonconst, printed later with c: prefix
        preres=wg_mkatom(db,mpool,WG_ANONCONSTTYPE,valstr,NULL);       
      } else {          
        // non-capital-letter uri, do not have to make anon and later prefix with c:
        if (!modified) preres=cl;
        else preres=wg_mkatom(db,mpool,WG_URITYPE,valstr,NULL);  
      }
    } else {
      // other non-uri atom
      preres=cl;
    }    
  } else {
    // a list
    head=wg_first(db,cl);    
    r1=wg_rest(db,cl);
    if (r1!=NULL) {
      r1el=wg_first(db,r1);
      r2=wg_rest(db,r1);    
    } else {
      r1el=NULL;
      r2=NULL;
    }   
    if (atomlevel && wg_isatom(db,r1el) && r1el &&
        (!strcmp("=",wg_atomstr1(db,r1el)) | 
         !strcmp("!=",wg_atomstr1(db,r1el)) )) {  
      if (r2==NULL) {
        wr_show_jsparse_error(g,pp,"too few arguments for = or !=");
        return NULL;
      }         
      if (wg_rest(db,r2)!=NULL) {
        wr_show_jsparse_error(g,pp,"too many arguments for = or !=");
        return NULL;
      }           
      a1=wr_process_json_term(g,pp,head,0,1);
      a2=wr_process_json_term(g,pp,wg_first(db,r2),0,2);
      if (!a1 || !a2) return NULL;
      if (!strcmp("=",wg_atomstr1(db,r1el)))  {
        *((gint*)cl)=(gint)(pp->atomeq);
        *((gint*)r1)=(gint)a1; 
        *((gint*)r2)=(gint)a2; 
        preres=cl;
      } else {
        *((gint*)cl)=(gint)(pp->atomeq);
        *((gint*)r1)=(gint)a1;
        *((gint*)r2)=(gint)a2;
        preres=wg_mklist2(db,mpool,pp->logneg,cl);         
      }  
      if (preres==NULL) {
        wr_show_jsparse_error(g,pp,"failed to process = : memory overflow");
        return NULL;
      }
      //return preres;
    } else if (!atomlevel && wg_isatom(db,r1el) && r1el &&
        wg_atomstr1(db,r1el) &&  
        (!strcmp("+",wg_atomstr1(db,r1el)) | 
         !strcmp("*",wg_atomstr1(db,r1el)) |
         !strcmp("-",wg_atomstr1(db,r1el)) |
         !strcmp("/",wg_atomstr1(db,r1el)))) {  
      if (r2==NULL) {
        wr_show_jsparse_error(g,pp,"too few arguments for arithmetic operation");
        return NULL;
      }         
      if (wg_rest(db,r2)!=NULL) {
        wr_show_jsparse_error(g,pp,"too many arguments for arithmetic operation");
        return NULL;
      }           
      a1=wr_process_json_term(g,pp,head,0,1);
      a2=wr_process_json_term(g,pp,wg_first(db,r2),0,2);
      if (!a1 || !a2) return NULL;
      
      *((gint*)cl)=(gint)r1el;
      *((gint*)r1)=(gint)a1; 
      *((gint*)r2)=(gint)a2; 
      preres=cl;

    } else if (atomlevel &&  wg_isatom(db,head) && 
        (!strcmp("=",wg_atomstr1(db,head)) | 
         !strcmp("!=",wg_atomstr1(db,head)) |
         !strcmp("-=",wg_atomstr1(db,head)) |
         !strcmp("~=",wg_atomstr1(db,head)) )) { 
      if (r2==NULL) {
        wr_show_jsparse_error(g,pp,"too few arguments for = or !=");
        return NULL;
      }         
      if (wg_rest(db,r2)!=NULL) {
        wr_show_jsparse_error(g,pp,"too many arguments for = or !=");
        return NULL;
      }     
      a1=wr_process_json_term(g,pp,r1el,0,1);
      a2=wr_process_json_term(g,pp,wg_first(db,r2),0,2);
      if (!a1 || !a2) return NULL;
      if (!strcmp("=",wg_atomstr1(db,head)))  {
        *((gint*)cl)=(gint)(pp->atomeq);
        *((gint*)r1)=(gint)a1;
        *((gint*)r2)=(gint)a2;
        preres=cl;
      } else {
        *((gint*)cl)=(gint)(pp->atomeq);
        *((gint*)r1)=(gint)a1;
        *((gint*)r2)=(gint)a2;
        preres=wg_mklist2(db,mpool,pp->logneg,cl);
        if (preres==NULL) {
          wr_show_jsparse_error(g,pp,"failed to process = : memory overflow");
          return NULL;
        }
      }
      //return preres;       
    } else if (!wg_isatom(db,head)) {      
      wr_show_jsparse_error(g,pp,"atom must not start with a list");
      return NULL;
    } else if (wg_atomtype(db,head)!=WG_URITYPE && wg_atomtype(db,head)!=WG_ANONCONSTTYPE) {   
      wr_show_jsparse_error(g,pp,"atom must start with a constant");
      return NULL;
    } else if ((wg_atomstr1(db,head))[0]=='\0') {
      wr_show_jsparse_error(g,pp,"atom must not start with an empty string");
      return NULL;
    } else if (atomlevel && 
                ( (wg_atomstr1(db,head))[0]=='-' ||
                  (wg_atomstr1(db,head))[0]=='~' )) {  
      //tmpres=NULL;
      for(n=0,part=cl; part!=NULL; part=wg_rest(db,part),n++) {
        tmp=wr_process_json_term(g,pp,wg_first(db,part),0,n);
        if (tmp==NULL) return NULL;
        *((gint*)part)=(gint)tmp;
        //tmpres=wg_mkpair(db,mpool,tmp,tmpres);
      }                          
      tmp=wg_mkatom(db,mpool,WG_URITYPE,(wg_atomstr1(db,head)+1),NULL);      
      *((gint*)cl)=(gint)tmp;
      preres=wg_mklist2(db,mpool,pp->logneg,cl);
      if (!tmp || !preres) {
        wr_show_jsparse_error(g,pp,"cannot process neg atom: memory overflow");
        return NULL;
      }
    } else if (wg_isatom(db,head) && 
              (!strcmp("exists",wg_atomstr1(db,head)) || !strcmp("all",wg_atomstr1(db,head))) ) {      
      if (r1==NULL) {
        wr_show_jsparse_error(g,pp,"not enough arguments for quantifier");
        return NULL;
      }
      if (r2==NULL) {
        wr_show_jsparse_error(g,pp,"not enough arguments for quantifier");
        return NULL;
      }      
      (pp->boundvars)=wg_mkpair(db,mpool,r1el,(pp->boundvars));
      tmp=wr_process_json_term(g,pp,wg_first(db,r2),1,1);
      (pp->boundvars)=wg_rest(db,(pp->boundvars));
      if (tmp==NULL) return NULL;
      *((gint*)r2)=(gint)tmp;
      preres=cl;
    } else {       
      for(n=0,part=cl; part!=NULL; part=wg_rest(db,part),n++) {
        tmp=wr_process_json_term(g,pp,wg_first(db,part),0,n);
        if (tmp==NULL) return NULL;
        *((gint*)part)=(gint)tmp;
      }     
      preres=cl;
    }
  } 
  if (atomlevel && pp->nullvars) {
    preres=wg_mklist3(db,mpool,pp->logexists,pp->nullvars,preres);
  } 
  return preres;
}

int wr_json_is_expandable_uristr(glb* g, char* keystr) {
  char* colptr;
  
  if (!keystr) return 0;
  if (*keystr==0) return 0;  
  colptr=strchr(keystr,':');
  if (colptr) {
    // keystr contains colon : can it be expanded?    
    if (*(keystr+1)==':' && ((*(keystr)=='_') || (*(keystr)=='?'))) return 0;
    if (*(colptr+1)=='/' && *(colptr+2)=='/') return 0;
    return 1;
  }
  return 1;  
}

void* wr_process_json_list(glb* g, parse_parm* pp, void* cl) { 
  void* db=g->db;
  void* mpool=pp->mpool;
  void* res=NULL;
  void *term, *termpart, *fun;

#ifdef DEBUG
  printf("\nwr_process_json_list:\n");
  wg_mpool_print(db,cl);
  printf("\n");
#endif

  res=wg_mkatom(db,mpool,WG_URITYPE,"$nil",NULL);  
  termpart=cl;
  if (!termpart) return res;
  fun=wg_mkatom(db,mpool,WG_URITYPE,"$list",NULL);
  if (!wg_ispair(db,termpart)) return wg_mklist3(db,mpool,fun,termpart,res);
  term=NULL;
  termpart=wg_inplace_reverselist(db,mpool,termpart);  
  for(;wg_ispair(db,termpart);termpart=wg_rest(db,termpart)) {
    if (g->parse_errflag) return NULL;
    term=wg_first(db,termpart);
    if (wg_ispair(db,term)) {
      term=wr_process_json_list(g,pp,term);
    }   
    if (!res) return NULL;
    res=wg_mklist3(db,mpool,fun,term,res);
  }
  return res;
}

void* wr_json_list_logconn(glb* g, parse_parm* pp, void* cl) {
  void* db=g->db;
  void* part;
  void* el;
  void* foundconn=NULL;
  int nr;

  if (cl==NULL) return NULL;
  if (wg_isatom(db,cl)) return NULL;
  for(part=cl,nr=0; wg_ispair(db,part); part=wg_rest(db,part),nr++) {   
    el=wg_first(db,part);
    if (wg_isatom(db,el) && (!wg_atomstr1(db,el) || !(wg_atomstr1(db,el)[0])))
      continue;
    if (wr_json_is_connective(g,el)) {
      if (foundconn==NULL) {
        foundconn=el;
      } else if (!wr_json_equal_atoms(g,foundconn,el)) {
        //(g->parse_errflag)=1;
        wr_show_jsparse_error(g,pp,"different logical connectives in list: %s %s",foundconn,el);
        //printf("\nerr %s\n",(g->parse_errmsg));
        //json_err_printf2("different logical connectives in list containing", char* s2)
        return NULL;
      }
    }
  }
  return foundconn;      
}

int wr_json_is_atomlist(void* db,void* ptr) {
  void *el;

#ifdef DEBUG
  printf("\nwr_json_is_atomlist called with\n");
  wg_mpool_print(db,ptr);
  printf("\n");
#endif
  if (ptr==NULL) return 0;
  if (wg_isatom(db,ptr)) return 0;
  while(ptr != NULL) {    
    el=wg_first(db,ptr);
    if (!wg_isatom(db,el) || wg_atomtype(db,el)!=WG_URITYPE) return 0;
    ptr=wg_rest(db,ptr);   
  }
  return 1;
}

int wr_json_is_connective(glb* g,void* ptr) {
  void* db=g->db;
  char* str;

  if (!wg_isatom(db,ptr) || 
      (wg_atomtype(db,ptr)!=WG_URITYPE &&
       wg_atomtype(db,ptr)!=WG_ANONCONSTTYPE)) return 0; 
  str=wg_atomstr1(db,ptr);
  if (!strcmp("not",str)) return 1;
  if (!strcmp("~",str)) return 1;
  if (!strcmp("-",str)) return 1;

  if (!strcmp("and",str)) return 1;
  if (!strcmp("or",str)) return 1;   
  if (!strcmp("&",str)) return 1;
  if (!strcmp("|",str)) return 1;

  if (!strcmp("if",str)) return 1;
  
  if (!strcmp("forall",str)) return 1;
  if (!strcmp("exists",str)) return 1;

  if (!strcmp("<=>",str)) return 1;
  if (!strcmp("=>",str)) return 1;
  if (!strcmp("<=",str)) return 1;
  if (!strcmp("<~>",str)) return 1;
  if (!strcmp("~|",str)) return 1;
  if (!strcmp("~&",str)) return 1;
  if (!strcmp("@",str)) return 1;
  
  //if (!strcmp("=",str)) return 1;
  //if (!strcmp("!=",str)) return 1;

  return 0;  
}


int wr_json_is_eq_op(glb* g,void* ptr) {
  void* db=g->db;
  char* str;

  if (!wg_isatom(db,ptr) || wg_atomtype(db,ptr)!=WG_URITYPE) return 0; 
  str=wg_atomstr1(db,ptr);
  if (!strcmp("=",str)) return 1;
  if (!strcmp("~=",str)) return 1;
  if (!strcmp("-=",str)) return 1;
  if (!strcmp("!=",str)) return 1;
  
  //if (!strcmp("=",str)) return 1;
  //if (!strcmp("!=",str)) return 1;

  return 0;  
}

void* wr_json_translate_connective(glb* g,parse_parm* pp,void* ptr) {
  void* db=g->db;
  char* str;

  //if (!wg_isatom(db,ptr) || wg_atomtype(db,ptr)!=WG_STRTYPE) return 0; 
  str=wg_atomstr1(db,ptr);
  if (!strcmp("not",str)) return pp->logneg;
  if (!strcmp("~",str)) return  pp->logneg;
  if (!strcmp("-",str)) return  pp->logneg;

  if (!strcmp("and",str)) return pp->logand;
  if (!strcmp("or",str)) return pp->logor;   
  if (!strcmp("&",str)) return pp->logand;
  if (!strcmp("|",str)) return pp->logor;

  if (!strcmp("forall",str)) return pp->logexists;
  if (!strcmp("exists",str)) return pp->logall; 

  if (!strcmp("<=>",str)) return pp->logeqv;
  if (!strcmp("=>",str)) return pp->logimp;
  if (!strcmp("<=",str)) return pp->logimp;
  if (!strcmp("<~>",str)) return pp->logeqv;
  if (!strcmp("~|",str)) return pp->logor;
  if (!strcmp("~&",str)) return pp->logand;
  if (!strcmp("@",str)) return pp->logat;

  if (!strcmp("ask",str)) return pp->logask;   
  //if (!strcmp("=",str)) return NULL;
  //if (!strcmp("!=",str)) return NULL;

  return NULL;  
}

int wr_json_negtype_connective(glb* g,parse_parm* pp,void* ptr) {
  void* db=g->db;
  char* str;

  //if (!wg_isatom(db,ptr) || wg_atomtype(db,ptr)!=WG_STRTYPE) return 0; 
  str=wg_atomstr1(db,ptr);
  
  if (!strcmp("<~>",str)) return 1;
  if (!strcmp("~|",str)) return 1;
  if (!strcmp("~&",str)) return 1;
 
  return 0;  
}

int wr_is_json_freevar(glb* g,parse_parm* pp,void* ptr) {
  void* db=g->db;
  char *s;
  if (!wg_isatom(db,ptr) || wg_atomtype(db,ptr)!=WG_URITYPE) return 0;
  s=wg_atomstr1(db,ptr);
  if ((*s)=='\0') return 0;
  if ((*s)!='?') return 0;
  s++;
  if ((*s)=='\0') return 0;
  if ((*s)!=':') return 0;
  s++;
  if ((*s)=='\0') return 0;
  return 1;
  /*
  if (*s >= 'A' && *s <= 'Z') return 1; 
  if (*s == '?') return 1;     
  return 0;
  */
}  

int wr_json_equal_atoms(glb* g,void* a1, void* a2) {
  void* db=g->db;
  char* str1;
  char* str2;

  if (!wg_isatom(db,a1) || wg_atomtype(db,a1)!=WG_URITYPE) return 0;
  if (!wg_isatom(db,a2) || wg_atomtype(db,a2)!=WG_URITYPE) return 0;
  str1=wg_atomstr1(db,a1);
  str2=wg_atomstr1(db,a2);
  if (!strcmp(str1,str2)) return 1;
  return 0;
}

int wr_json_really_equal_atoms(glb* g,void* a1, void* a2) {
  void* db=g->db;
  char* str1;
  char* str2;
  /*
  printf("\nwr_json_really_equal_atoms\n");
  wg_mpool_print(db,a1);
  printf("\n");
  wg_mpool_print(db,a2);
  printf("\n");
  */
  if (!wg_isatom(db,a1)) return 0;
  if (!wg_isatom(db,a2)) return 0;
  str1=wg_atomstr1(db,a1);
  str2=wg_atomstr1(db,a2);
  if (!strcmp(str1,str2)) {
    //printf("\nequal\n");
    return 1;
  }  
  return 0;
}

void* wr_json_process_if_then(glb* g, parse_parm* pp, void* ptr) {
  void* mpool=pp->mpool;
  void* db=g->db;
  void *res; //,*a2,*a1r,*rst;
  void *el, *cond=NULL, *conseq=NULL;
  void* part;
  int incond=1, condcount=0, conseqcount=0;

  //printf("\nwr_json_process_if_then called\n");
  for(part=wg_rest(db,ptr); part!=NULL;  part=wg_rest(db,part)) {
    el=wg_first(db,part);
    if (wg_isatom(db,el) && wg_atomtype(db,el)==WG_URITYPE &&
        !strcmp(wg_atomstr1(db,el),"then")) {
      incond=0;
      continue;
    }
    el=wr_process_json_formula_aux(g,pp,el);
    if (el==NULL) return NULL;
    if (incond) {
      condcount++;
      cond=wg_mkpair(db,mpool,el,cond);
    } else {
      conseqcount++;
      conseq=wg_mkpair(db,mpool,el,conseq);
    }   
  }
  if (incond) {
    wr_show_jsparse_error(g,pp,"if ... construction has no then part");
    return NULL;
  }
  if (!condcount) {
    wr_show_jsparse_error(g,pp,"if ... then ... construction has no conditions");
    return NULL;
  }
  if (!conseqcount) {
    wr_show_jsparse_error(g,pp,"if ... then ... construction has no consequences");
    return NULL;
  }
  if (condcount>1) {
    cond=wg_inplace_reverselist(db,mpool,cond);
    cond=wg_mkpair(db,mpool,pp->logprefixand,cond);
    cond=wr_json_unflatten_logic(g,pp,cond,pp->logand,pp->logand,1,0);
  } else {
    cond=wg_first(db,cond);
  }
  if (conseqcount>1) {
    conseq=wg_inplace_reverselist(db,mpool,conseq);
    conseq=wg_mkpair(db,mpool,pp->logor,conseq);
    conseq=wr_json_unflatten_logic(g,pp,conseq,pp->logor,pp->logor,1,0);
  } else {
    conseq=wg_first(db,conseq);
  }
  if (!cond || !conseq) {
    wr_show_jsparse_error(g,pp,"failed to process if ... then ... construction: memory overflow");
    return NULL;
  }
  res=wg_mklist3(db,mpool,pp->logimp,cond,conseq);
  if (!res) {
    wr_show_jsparse_error(g,pp,"failed to process if ... then ... construction: memory overflow");
    return NULL;
  }
  return res;
}  


/*  

  & 
  to
  &

  (&)
  to
  &

  (& a)
  to 
  a

  (a & b)
  to 
  (& b a)

  (a & b & c)
  to
  (& (& c b) a)

  (a & b & c & d)
  to
  (& (& (& d c) b) a)

*/

void* wr_json_unflatten_logic(glb* g, parse_parm* pp, void* ptr, 
          void* conn, void* newconn, int ispos, int isreverse) {
  void* mpool=pp->mpool;            
  void* db=g->db;
  void *res,*a2,*a1r,*rst,*tmp;

#ifdef DEBUG    
  printf("\nwr_json_unflatten_logic called with isreverse %d\n",isreverse);
  wg_mpool_print(db,ptr);
  printf("\nnewconn");
  wg_mpool_print(db,newconn);
  printf("\n");
#endif  
  if (ptr==NULL) return NULL;
  if (wg_isatom(db,ptr)) {
    if (wr_json_really_equal_atoms(g,ptr,conn)) return NULL;
    else return wr_process_json_formula_aux(g,pp,ptr);
  }  
  rst=wg_rest(db,ptr);
  if (wr_json_equal_atoms(g,wg_first(db,ptr),conn)) {
    return wr_json_unflatten_logic(g,pp,rst,conn,newconn,ispos,isreverse);
  }
  if (rst==NULL) {      
    return wr_process_json_formula_aux(g,pp,wg_first(db,ptr));
  } 
  a1r=wr_json_unflatten_logic(g,pp,rst,conn,newconn,ispos,isreverse);
  a2=wg_first(db,ptr);
  if (wr_json_really_equal_atoms(g,a2,conn)) {
    return a1r;
  } else if (a1r==NULL) {
    return wr_process_json_formula_aux(g,pp,a2);
  } else {  
    a2=wr_process_json_formula_aux(g,pp,a2);
    if (ispos) {
      if (isreverse) {
        if (wr_json_really_equal_atoms(g,newconn,a2)) res=a1r;
        else res=wg_mklist3(db,mpool,newconn,a2,a1r);
        //res=wg_mklist3(db,mpool,newconn,a2,a1r);
      } else {
        if (wr_json_really_equal_atoms(g,newconn,a1r)) res=a2;
        else res=wg_mklist3(db,mpool,newconn,a1r,a2);
      }  
    } else {
      if (wr_json_really_equal_atoms(g,newconn,a1r)) tmp=a2;
      else tmp=wg_mklist3(db,mpool,newconn,a1r,a2);
      if (!tmp) {
        return NULL;
      }
      res=wg_mklist2(db,mpool,pp->logneg,tmp);
    }  
#ifdef DEBUG     
  printf("\nwr_json_unflatten_logic res\n");
  wg_mpool_print(db,res); 
  printf("\n");
#endif  
    return res;
  }         
}

void* wr_json_make_nullvar(glb* g, parse_parm* pp) {
  void* db=g->db;
  void* mpool=pp->mpool;
  int nr, found;
  void* atom;
  void* part;
  char buf[20];


  (pp->nullvarsnr)++;  
  for(; 1; (pp->nullvarsnr)++) {
    nr=pp->nullvarsnr;
    if (nr>10000) {
      wr_show_jsparse_error(g,pp,"failed to create a new variable for null");
      return NULL;
    }
    sprintf(buf,"%s%d",MPOOL_NULLVAR_PREFIX,nr);
    atom=wg_mkatom(db,mpool,WG_URITYPE,buf,NULL);

    if (wg_list_memberuri(db,(pp->freevars),atom)) continue;
    found=0;
    for(part=(pp->boundvars); part!=NULL; part=wg_rest(db,part)) {          
      if (wg_list_memberuri(db,wg_first(db,part),atom)) {
        found=1;
        break;
      }
    }
    if (found) continue;
    break;   
  }
  return atom;  
}

/* ------- convert clausified json clause to a record ------- */



void* wr_js_parse_clauselist(glb* g,void* mpool,cvec clvec,void* clauselist) {
  void* db=g->db;
  void* lpart;
  void* cl;
  int clnr=0;
  void *clause, *name, *role;
  void* record=NULL;
  void* resultlist=NULL;
  char** vardata;
  int i,len;
  void* propfun;
  void *frm, *flt, *fltpart, *context;
  gint cell;
  gcell *cellptr;
  
#ifdef DEBUG  
  DPRINTF("wr_js_parse_clauselist starting with clauselist\n");  
  wg_mpool_print(db,clauselist); 
  DPRINTF("\n");
#endif
  if (clvec!=NULL) CVEC_NEXT(clvec)=CVEC_START; 
  // create vardata block by malloc or inside mpool

  vardata=(char**)(wg_alloc_mpool(db,mpool,sizeof(char*)*VARDATALEN));
  if (vardata==NULL) {
    wr_show_parse_error(g,"cannot allocate vardata in wr_js_parse_clauselist");
    //(g->parse_errflag)=1;
    return NULL;
  }  
  //vardata=(char**)(malloc(sizeof(char*)*VARDATALEN));
  for(i=0;i<VARDATALEN;i++) vardata[i]=NULL; // pointers to varstrings  
  propfun=wg_mkatom(db,mpool,WG_URITYPE,PROPVAR_PREDSYMB,NULL);
  // loop over clauses  
  for(lpart=clauselist,clnr=0;wg_ispair(db,lpart);lpart=wg_rest(db,lpart),clnr++) {
    //if (clnr%10000==0) printf("clnr %d\n",clnr)
    if (g->parse_errflag) break;
    clause=wg_first(db,lpart);  
#ifdef DEBUG
    printf("\nclause in the wr_js_parse_clauselist loop:\n");
    wg_mpool_print(db,clause);
    printf("\n");
#endif
    context=NULL;
    if (!wg_ispair(db,clause)) {
      name=NULL;
      role=NULL;
      frm=clause;
    } else {
      len=wg_list_len(db,clause);
      if ((len!=3) && (len!=4)) {
        wr_show_parse_error(g,"clause in wg_parse_clauselist should have length 3 or 4");
        //(g->parse_errflag)=1;
        return NULL;
      }
      name=wg_nth(db,clause,0);
      role=wg_nth(db,clause,1);
      frm=wg_nth(db,clause,2);     
      if (len==4) context=wg_nth(db,clause,3);  
    }
#ifdef DEBUG     
    printf("\nin wr_js_parse_clauselist frm nr %d:\n",clnr);    
    wg_mpool_print(db,frm); 
    printf("\n");
#endif
    flt=wr_flatten_logclause(g,mpool,frm);
#ifdef DEBUG 
    printf("\nin wr_js_parse_clauselist got flt nr %d:\n",clnr);    
    wg_mpool_print(db,flt); 
    printf("\n");
#endif
    for(fltpart=flt; fltpart!=NULL; fltpart=wg_rest(db,fltpart)) {
      cl=wg_first( db,fltpart);
#ifdef DEBUG
      printf("\nin wr_parse_clauselist inner cl nr %d:\n",clnr);    
      wg_mpool_print(db,cl); 
      printf("\n");
#endif      
      record=wr_js_parse_clause(g,mpool,cl,clvec,vardata,propfun,name,role,context);    
      if (!record) continue; // parsing failed if NULL 
      // add record to the clauselist in db
      cell=alloc_listcell(db);
      if (!cell) {
        wr_show_parse_error(g,"failed to allocate a cell");
        //(g->parse_errflag)=1;
        return NULL;
      }  
      cellptr = (gcell *) offsettoptr(db, cell);
      (cellptr->car) = ptrtooffset(db, record);
      (cellptr->cdr) = (dbmemsegh(db)->clauselist);
      (dbmemsegh(db)->clauselist) = cell;       
      // add to resultlist, which is not really needed   
      resultlist=wg_mkpair(db,mpool,record,resultlist); // not really needed!!
      if (!resultlist) {
        wr_show_parse_error(g,"failed to add a clause to resultlist");
        //(g->parse_errflag)=1;
        return NULL;
      }
      // if clvec present, store record to clvec, given enough space
      if (clvec!=NULL) {
        if ((clvec[1]+1)<clvec[0]) {
          clvec[clvec[1]]=(gint)record; 
          ++(clvec[1]);
        } 
      }    
    }
  } // end clause list loop 
  //DPRINTF("\nwr_js_parse_clauselist ending\n");
  //free(vardata); // if taken from mpool, not freed
  return resultlist;
}  

void* wr_js_parse_clause(glb* g,void* mpool,void* cl,cvec clvec,
        char** vardata,void* propfun, void* name, void* role, void* context) {
  void* db=g->db;
  void *clpart, *lit, *atom;
  int clnr=0;
  int litnr=0;
  int isneg=0;
  void *fun, *tmpptr, *atomres;
  gint ameta, tmpres2, setres, setres2, history;
  void* record=NULL;
  int issimple, i;
  void *termpart, *subterm;
  char *namestr, *rolestr;
  int rolenr;
  void* resultlist=NULL;

#ifdef DEBUG    
  printf("\n++ in wr_js_parse_clause clause is: %d\n",clnr);    
  wg_mpool_print(db,cl); 
  printf("\n");
  printf("\n++ in wr_js_parse_clause context is: \n");    
  wg_mpool_print(db,context); 
  printf("\n");
#endif
  if (!wg_ispair(db,cl)) {    
    //show_parse_warning(db,"clause nr %d is atomic: ",clnr); 
    cl=wg_mklist1(db,mpool,cl);
#ifdef DEBUG      
    wg_mpool_print(db,cl); 
    printf("\n");    
    printf("\nCP1X\n");
#endif      
    //return NULL;
  }  
  // examine clause: find clause length and check if simple clause    
  issimple=1;
  litnr=0;
  for(clpart=cl;wg_ispair(db,clpart);clpart=wg_rest(db,clpart),litnr++) {
    if (g->parse_errflag) return NULL;
    lit=wg_first(db,clpart); 
#ifdef DEBUG      
    printf("\nlit: ");
    wg_mpool_print(db,lit); 
    printf("\n");      
#endif      
    if (!wg_ispair(db,lit)) { issimple=0; continue; }
    fun=wg_first(db,lit);
    if (wg_atomtype(db,fun)==WG_ANONCONSTTYPE && !strcmp(wg_atomstr1(db,fun),"not")) { issimple=0; continue; }
    for(termpart=lit;wg_ispair(db,termpart);termpart=wg_rest(db,termpart)) {
      subterm=wg_first(db,termpart);
#ifdef DEBUG        
      printf("\nsubterm: ");
      wg_mpool_print(db,subterm); 
      printf("\n");
#endif        
      if (subterm!=NULL && wg_ispair(db,subterm)) { issimple=0; break; }     
      if (wg_atomtype(db,subterm)==WG_VARTYPE) { issimple=0; break; } 
      if (wg_atomtype(db,subterm)==WG_URITYPE &&  
          ( (g->parse_caps_as_var && isupper(wg_atomstr1(db,subterm)[0])) ||
            (g->parse_question_as_var && wg_atomstr1(db,subterm)[0]=='?') )) {issimple=0; break;} 
    }      
  }        
  if (litnr>1) issimple=0;   
  // create record for a rule clause
  if (!issimple) {
    record=wr_create_rule_clause(g,litnr);   
    if (((gint)record)==0) {
      //free(vardata);
      return NULL;
    }
    resultlist=wg_mkpair(db,mpool,record,resultlist);       
  }  
  // clear vardata block for the next clause
  for(i=0;i<VARDATALEN;i++) {
    if (vardata[i]==NULL) break;
    vardata[i]=NULL;       
  }      
  // process one clause
  for(clpart=cl,litnr=0;wg_ispair(db,clpart);clpart=wg_rest(db,clpart),litnr++) {      
    if (g->parse_errflag) return NULL;
    lit=wg_first(db,clpart);
#ifdef DEBUG    
    printf("\nlit nr  %d:",litnr);    
    wg_mpool_print(db,lit); 
    printf("\n");
#endif      
    if (!wg_ispair(db,lit)) {        
      lit=wg_mkpair(db,mpool,propfun,wg_mkpair(db,mpool,lit,NULL));
      if (!lit) {
        //show_parse_warning(db,"failed to make a literal"); 
        wr_show_parse_error(g,"failed to make a literal");
        return NULL;
      }
      //show_parse_warning(db,"lit nr %d in clause nr %d is atomic and hence prefixed: ",litnr,clnr); 
      //wg_mpool_print(db,lit);
      //printf("\n");
#ifdef DEBUG        
      wg_mpool_print(db,lit); 
      printf("\n");
#endif        
      //continue;
    }               
    fun=wg_first(db,lit);
    if (!wg_isatom(db,fun)) {
      //show_parse_warning(db,"lit nr %d in clause nr %d has nonatomic leadfun and hence ignored: ",litnr,clnr); 
      wr_show_parse_error(g,"lit nr %d in clause nr %d has nonatomic leadfun and hence ignored: ",litnr,clnr);
#ifdef DEBUG        
      wg_mpool_print(db,fun); 
      printf("\n");
#endif        
      //continue;
      return NULL;
    }     
    isneg=0;
    if (wg_atomtype(db,fun)==WG_ANONCONSTTYPE && 
        !strcmp(wg_atomstr1(db,fun),"not") &&
        wg_atomstr2(db,fun)==NULL) {
      //DPRINTF("detected negation");
      isneg=1;            
      tmpptr=wg_rest(db,lit);    
      if (!wg_ispair(db,tmpptr)) {          
        //show_parse_warning(db,"lit nr %d in clause nr %d does not contain proper atom after negation and hence ignored: ",litnr,clnr);         
        wr_show_parse_error(g,"lit nr %d in clause nr %d does not contain proper atom after negation and hence ignored: ",litnr,clnr);
#ifdef DEBUG          
        wg_mpool_print(db,lit); 
        printf("\n");
#endif          
        //continue;
        return NULL;
      } 
      atom=wg_first(db,tmpptr);
      if (!wg_ispair(db,atom)) {
        atom=wg_mkpair(db,mpool,propfun,wg_mkpair(db,mpool,atom,NULL));
        if (!atom) {
          //show_parse_warning(db,"failed to make an atom"); 
          wr_show_parse_error(g,"failed to make an atom"); 
          return NULL;
        }        
        //show_parse_warning(db,"lit nr %d in clause nr %d was atomic and is prefixed\n: ",litnr,clnr); 
#ifdef DEBUG          
        wg_mpool_print(db,lit); 
        printf("\n");
#endif          
        //continue;
      }
      fun=wg_first(db,atom);
      if (!wg_isatom(db,fun)) {
        //show_parse_warning(db,"lit nr %d in clause nr %d has nonatomic leadfun and hence ignored: ",litnr,clnr); 
        wr_show_parse_error(g,"lit nr %d in clause nr %d has nonatomic leadfun and hence ignored",litnr,clnr);
        //(g->parse_errflag)=1;
#ifdef DEBUG          
        wg_mpool_print(db,fun); 
        printf("\n");
#endif          
        //continue;
        return NULL;
      }         
    } else {
      atom=lit;
    }      
#ifdef DEBUG      
    DPRINTF("atom isneg %d: ",isneg);
    wg_mpool_print(db,atom);
#endif      
    // parse an atom in the clause
    atomres=wr_parse_atom(g,mpool,atom,isneg,issimple,vardata); 
    if (atomres==NULL) {
      wr_show_parse_error(g,"problem converting an atom to record");
      //(g->parse_errflag)=1;
      //free(vardata);
      return NULL;        
    }
    if (issimple) {
      wr_convert_atom_fact_clause(g,atomres,isneg);
      resultlist=wg_mkpair(db,mpool,atomres,resultlist);
      if (!resultlist) {
        //show_parse_warning(db,"failed to extend resultlist"); 
        wr_show_parse_error(g,"failed to extend resultlist"); 
        //(g->parse_errflag)=1;         
        return NULL;          
      }       
      record=atomres; // for storage of record in clvec
      break;        
    } else {     
      ameta=0;        
      if (isneg) ameta=(ameta | ATOM_META_NEG);      
      setres=wr_set_rule_clause_atom_meta(g,record,litnr,ameta);                
      tmpres2=wg_encode_record(db,atomres);
      setres2=wr_set_rule_clause_atom(g,record,litnr,tmpres2);
      if (setres!=0 || setres2!=0) {
        // wg_delete_record(db,atomres); // might leak memory
        wr_free(g,vardata);
        return NULL; 
      }   
    }        
          
  } // end one clause processing loop
  // set history 
  if (name && wg_isatom(db,name) && wg_atomtype(db,name)==WG_URITYPE) {
    namestr=wg_atomstr1(db,name);
    if (!(namestr[0])) namestr=NULL;    
  } else {
    namestr=NULL;
  }  
  if (role && wg_isatom(db,role) && wg_atomtype(db,role)==WG_URITYPE) {
    rolestr=wg_atomstr1(db,role);        
    if (!strcmp("conjecture",rolestr) || !strcmp("negated_conjecture",rolestr)) {       
      rolenr=PARSER_GOAL_ROLENR;          
    } else if (!strcmp("hypothesis",rolestr) || !strcmp("assumption",rolestr)) {     
      rolenr=PARSER_ASSUMPTION_ROLENR;  
    } else if (!strcmp("axiom",rolestr) && 
             //  (g->parse_is_included_file) &&
             namestr!=NULL &&
             !strncmp(namestr,IMPORTED_NAME_PREFIX,strlen(IMPORTED_NAME_PREFIX)) ) {  
      rolenr=PARSER_EXTAXIOM_ROLENR;   
    } else {
      rolenr=PARSER_AXIOM_ROLENR; 
    }  
  } else {
    rolenr=PARSER_AXIOM_ROLENR;
  }      
  history=wr_build_input_history(g,record,namestr,rolenr);
  if (!history) {
    //show_parse_warning(db,"failed to make history"); 
    //return NULL;          
  } 

  //printf("\nCP **** wr_build_input_history returned\n");
  //wg_print_record(db,history);
  //wr_print_clause(g,history);
  //printf("\n");

  //wr_set_input_history_ctxt(g,record,history,context); 
  wr_set_history(g,record,history); 
#ifdef DEBUG
  printf("\n built a record:\n");
  //wg_print_record(db_to_kb(db),record);
  wr_print_record(g,record);
  printf("\n");
#endif
  return record;
} 

void* wr_json_add_with_and(glb* g, parse_parm* pp, void* frm, void* previous) {
  void* db=g->db;
  void* mpool=pp->mpool;
  void* res;
  
  if (!previous) return frm;
  if (!frm) return previous;
  res=wg_mklist3(db,mpool,    
    pp->logand,
    frm,
    previous);
  return res;  
}

void* wr_json_add_with_negated_or(glb* g, parse_parm* pp, void* frm, void* previous) {
  void* db=g->db;
  void* mpool=pp->mpool;
  void* res;
  
  if (!previous) return frm;
  if (!frm) return previous;
  res=wg_mklist3(db,mpool,    
    pp->logor,
    frm,
    wg_mklist2(db,mpool,pp->logneg,previous));
  return res;  
}

void* wr_add_keyval_jsstruct(glb *g, parse_parm* pp, 
        void* key, void* keyval, void* jstruct) {
  void *db=g->db;
  void *mpool=pp->mpool;          
  void *tmp, *res;

  if (!keyval || !key) return jstruct;  
  if (!jstruct) {
    res=wg_mklist3(db,mpool,pp->jsonstruct,key,keyval);
  } else {
    tmp=wg_rest(db,jstruct);
    tmp=wg_mkpair(db,mpool,keyval,tmp);
    tmp=wg_mkpair(db,mpool,key,tmp);
    res=wg_mkpair(db,mpool,pp->jsonstruct,tmp);
  }  
  return res;
}

/* ------------ context --------------- */

int wr_json_extend_context(glb* g, parse_parm* pp, void* ctxt) {
  void* mpool=pp->mpool;
  void* db=g->db;
  void *vocab, *base, *part, *key, *value;
  char *keystr;
  void *internalidplace, *internalid, *val;
  //void* oldctxt;

  if (!ctxt || !wg_ispair(db,ctxt) || wg_first(db,ctxt)!=(pp->jsonstruct)) {    
    return 0;
  } 
  // now a struct
  // first search for @vocab and add this
  vocab=wg_get_keyval(db,pp->jsonld_vocabkey,ctxt);
  if (vocab) {   
    if (!wg_isatom(db,vocab) || wg_atomtype(db,vocab)!=WG_URITYPE || !wg_atomstr1(db,vocab)) {
      wr_show_parse_error(g,"@vocab value must be a string");      
      return -1;    
    }
    (pp->jsonld_ctxt)=wg_add_assoc(db,mpool,pp->jsonld_vocabkey,vocab,pp->jsonld_ctxt);    
  }
  base=wg_get_keyval(db,pp->jsonld_basekey,ctxt);
  /*
  printf("\n base\n");
  wg_mpool_print(db,base);
  printf("\n pp->jsonld_basekey\n");
  wg_mpool_print(db,pp->jsonld_basekey);
  printf("\n ctxt\n");
  wg_mpool_print(db,ctxt);
  printf("\n");
  */
  if (base) {   
    if (!wg_isatom(db,base) || wg_atomtype(db,base)!=WG_URITYPE || !wg_atomstr1(db,base)) {
      wr_show_parse_error(g,"@base value must be a string");      
      return -1;    
    }
    (pp->jsonld_base)=base;  
  }
  // now vocab is the value of @vocab
  // loop over all elems of ctxt
  for(part=wg_rest(db,ctxt); wg_ispair(db,part); part=wg_rest(db,part)) {
    if (wg_isatom(db,wg_first(db,part)) && wg_rest(db,part) && wg_first(db,wg_rest(db,part))) {
      key=wg_first(db,part);
      if (!key || wg_atomtype(db,key)!=WG_URITYPE) {
        part=wg_rest(db,part);
        if (!part) break;
        continue;
      }
      keystr=wg_atomstr1(db,key);
      value=wg_first(db,wg_rest(db,part));
      if (!keystr || !keystr[0] || (keystr && !strcmp(keystr,"@vocab"))) {
        part=wg_rest(db,part);
        if (!part) break;
        continue;
      }
      
      // here we have a valid key, keystr, value to be used
      if (wg_ispair(db,value) && wg_first(db,value)==pp->jsonstruct) {
        internalidplace=wg_get_keystrplace(db,"@id",value);      
        if (internalidplace && wg_ispair(db,internalidplace)) {
          internalid=wg_first(db,wg_rest(db,internalidplace));          
        } else {
          internalid=NULL;
        }
        if (internalid && wg_isatom(db,internalid) && wg_atomtype(db,internalid)==WG_URITYPE) {
          val=internalid;
          val=wr_json_expand_atom(g,pp->mpool,pp,internalid,0);         
          *((gint*)wg_rest(db,internalidplace))=(gint)val;
        } else if (internalid) {
          wr_show_parse_error(g,"wrong type of @id value in @context"); 
          return -1;
        }       
      } else {
        value=wr_json_expand_atom(g,pp->mpool,pp,value,0);
      }
      (pp->jsonld_ctxt)=wg_add_assoc(db,mpool,key,value,pp->jsonld_ctxt);
    } 
    part=wg_rest(db,part);
    if (!part) break;
  }  
  return 0;
}  

char* wg_modify_keystr_by_ctxt(glb* g, parse_parm* pp, char* buf, int buflen, char* keystr) {
  void* db=g->db;
  void *part, *el, *ctxtkey, *vocabstr, *val, *internalid=NULL;
  char *colptr, *ctxtkeystr, *valstr;
  int keylen, ctxtkeylen, valstrlen;
  
  if (!(pp->jsonld_ctxt) || !keystr) return keystr;  
  keylen=strlen(keystr);
  colptr=strchr(keystr,':');
  if (colptr) {
    // keystr contains colon : can it be expanded?
    if (*(keystr+1)==':' && ((*(keystr)=='_') || (*(keystr)=='?'))) return keystr;
    if (*(colptr+1)=='/' && *(colptr+2)=='/') return keystr;
  }

  for(part=pp->jsonld_ctxt; wg_ispair(db,part); part=wg_rest(db,part)) {
    el=wg_first(db,part);
    ctxtkey=wg_first(db,el);   
    // do not prefix with vocab if keystr contains colon at non-first place:
    if (ctxtkey==(pp->jsonld_vocabkey) && (!colptr || colptr==keystr)) {         
      // use vocab as a prefix  
      vocabstr=wg_atomstr1(db,wg_rest(db,el));
      if ((keylen+strlen(vocabstr)+10)>buflen) {
        wr_show_parse_error(g,"@vocab value + key is too long"); 
        return keystr;
      }
      strcpy(buf,vocabstr);
      strcat(buf,keystr);     
      return buf;
    }     
    ctxtkeystr=wg_atomstr1(db,ctxtkey);    
    ctxtkeylen=strlen(ctxtkeystr);
    if (!ctxtkeylen) continue;   
    val=wg_rest(db,el);
    if (!val) continue;

    if (wg_ispair(db,val)) {          
      //internalid=wg_get_keystrval(db,"@id",wg_rest(db,el)); 
      if (wg_first(db,val)==pp->jsonstruct) {
        internalid=wg_get_keystrval(db,"@id",val);       
        if (internalid && wg_isatom(db,internalid) && wg_atomtype(db,internalid)==WG_URITYPE) {
          val=internalid;
          //val=wr_json_expand_list_prefixes(g,pp->mpool,pp,internalid,0);
        } else if (internalid) {
          wr_show_parse_error(g,"wrong type of @id value in @context"); 
          return keystr;
        } else {
          continue;
        }       
      } else {
        wr_show_parse_error(g,"wrong type of @context value"); 
        return keystr;
      }            
    }
    valstr=wg_atomstr1(db,val);
    if (!valstr) continue;
    valstrlen=strlen(valstr);
    if (!valstrlen) continue;    
    // now try to match keystr to the ctxtkeystr
    if (!strcmp(keystr,ctxtkeystr)) {
      // exactly matching key found, use value of the key
      return valstr;
    }   
    if (colptr && !internalid && keylen>ctxtkeylen &&
        !strncmp(keystr,ctxtkeystr,ctxtkeylen) &&
        *(keystr+ctxtkeylen)==':' &&
        wg_suitable_context_uri_end(db,*(valstr+valstrlen-1))) {
      // key matches the before-colon part of the keystr      
      if ((keylen+valstrlen+10)>buflen) {
        wr_show_parse_error(g,"@context key value + key is too long"); 
        return keystr;
      }
      strcpy(buf,valstr);
      strcat(buf,colptr+1);
      return buf;
    }      
  }  
  return keystr;
}


void* wr_json_expand_atom(glb* g, void* mpool, parse_parm* pp, void* lst, int depth) {
  void* db=g->db;
  //void* res=NULL;
  void *ctxt, *keyval;
  char *valstr, *modvalstr;
  int buflen=1000;
  char keybuf[1000];

  ctxt=pp->jsonld_ctxt;
  if (!ctxt) return lst;
  if (wg_isatom(db,lst)) {
    // lst is an atom, not a real list
    if (wg_atomtype(db,lst)==WG_URITYPE) {
      keyval=lst;     
      valstr=wg_atomstr1(db,lst);
      modvalstr=wg_modify_keystr_by_ctxt(g,pp,keybuf,buflen,valstr);
      if (modvalstr!=valstr) {
        if (!modvalstr) valstr=keybuf;
        else valstr=modvalstr;
        keyval=wg_mkatom(db,mpool,WG_URITYPE,valstr,NULL);          
      }       
      return keyval;
    } else {
      return lst;
    }
  }   
  return lst;      
}
     

int wg_suitable_context_uri_end(void* db, char c) {
  // https://tools.ietf.org/html/rfc3986#section-2.2
  // ":" / "/" / "?" / "#" / "[" / "]" / "@"
  if (c==':') return 1;
  if (c=='/') return 1;
  if (c=='?') return 1;
  if (c=='#') return 1;
  if (c=='[') return 1;
  if (c==']') return 1;
  if (c=='@') return 1;
  return 0;
}


/* ------------ errors ---------------- */


void json_err_printf2(char* s1, char* s2) {
  if (s1 && s2) printf("{\"error\": \"%s %s\"}\n",s1,s2);
  else if (s1) printf("{\"error\": \"%s\"}\n",s1);
  else if (s2) printf("{\"error\": \"%s\"}\n",s2);
  else printf("{\"error\": \"unspecified\"}\n");  
}

void json_err_printfn2(char* s1, int num, char* s2)  {
  printf("{\"error\": \"%s %d %s\"}\n",s1,num,s2);
}

void json_err_printf3(char* s1, int num, char* s2) {
  printf("{\"error\": \"%s %d %s\"}\n",s1,num,s2);
}


static int wr_show_jsparse_error(glb* g, parse_parm* pp, char* format, ...) {
  //void* db=g->db;
  int tmp1,tmp2;
  va_list args;
  va_start (args, format);
  /*
  printf("*** Parser error: ");
  vprintf (format, args);  
  va_end (args);
  printf("\n");
  */  

  if (g->parse_errflag) return -1;
  (g->parse_errflag)=1;  
  if (g->parse_errmsg) return -1;
  (g->parse_errmsg)=malloc(1000);
  if (!(g->parse_errmsg)) return -1;
  if (pp && pp->formulanr) {
    if (pp->formulaname) {
      tmp1=snprintf((g->parse_errmsg),50,
            "{\"error\": \"error in formula nr %d %s: ",pp->formulanr,pp->formulaname);
    } else {
      tmp1=snprintf((g->parse_errmsg),50,
            "{\"error\": \"error in formula nr %d: ",pp->formulanr);
    }  
  } else {
    tmp1=snprintf((g->parse_errmsg),50,"{\"error\": \"json parser error: ");
  }  
  tmp2=vsnprintf((g->parse_errmsg)+tmp1,800,format,args);
  snprintf((g->parse_errmsg)+tmp1+tmp2,50,"\"}");

  /*
  printf("{\"error\": \"parser error: ");
  vprintf (format, args);
  va_end (args);
  printf("\"}\n");
  */
  //exit(1);
  return -1;  
}